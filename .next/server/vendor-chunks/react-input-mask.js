/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-input-mask";
exports.ids = ["vendor-chunks/react-input-mask"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-input-mask/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-input-mask/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("if (false) {} else {\n    module.exports = __webpack_require__(/*! ./lib/react-input-mask.development.js */ \"(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMsOEpBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWJkdWxheml6LXByb2dyYW1tZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9pbmRleC5qcz82YzVhIl0sInNvdXJjZXNDb250ZW50IjpbImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmVhY3QtaW5wdXQtbWFzay5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9yZWFjdC1pbnB1dC1tYXNrLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-input-mask/lib/react-input-mask.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar React = _interopDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar invariant = _interopDefault(__webpack_require__(/*! invariant */ \"(ssr)/./node_modules/invariant/invariant.js\"));\nvar warning = _interopDefault(__webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\"));\nfunction _defaults2(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        var value = Object.getOwnPropertyDescriptor(defaults, key);\n        if (value && value.configurable && obj[key] === undefined) {\n            Object.defineProperty(obj, key, value);\n        }\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _defaults2(subClass, superClass);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction setInputSelection(input, start, end) {\n    if (\"selectionStart\" in input && \"selectionEnd\" in input) {\n        input.selectionStart = start;\n        input.selectionEnd = end;\n    } else {\n        var range = input.createTextRange();\n        range.collapse(true);\n        range.moveStart(\"character\", start);\n        range.moveEnd(\"character\", end - start);\n        range.select();\n    }\n}\nfunction getInputSelection(input) {\n    var start = 0;\n    var end = 0;\n    if (\"selectionStart\" in input && \"selectionEnd\" in input) {\n        start = input.selectionStart;\n        end = input.selectionEnd;\n    } else {\n        var range = document.selection.createRange();\n        if (range.parentElement() === input) {\n            start = -range.moveStart(\"character\", -input.value.length);\n            end = -range.moveEnd(\"character\", -input.value.length);\n        }\n    }\n    return {\n        start: start,\n        end: end,\n        length: end - start\n    };\n}\nvar defaultFormatChars = {\n    \"9\": \"[0-9]\",\n    \"a\": \"[A-Za-z]\",\n    \"*\": \"[A-Za-z0-9]\"\n};\nvar defaultMaskChar = \"_\";\nfunction parseMask(mask, maskChar, formatChars) {\n    var parsedMaskString = \"\";\n    var prefix = \"\";\n    var lastEditablePosition = null;\n    var permanents = [];\n    if (maskChar === undefined) {\n        maskChar = defaultMaskChar;\n    }\n    if (formatChars == null) {\n        formatChars = defaultFormatChars;\n    }\n    if (!mask || typeof mask !== \"string\") {\n        return {\n            maskChar: maskChar,\n            formatChars: formatChars,\n            mask: null,\n            prefix: null,\n            lastEditablePosition: null,\n            permanents: []\n        };\n    }\n    var isPermanent = false;\n    mask.split(\"\").forEach(function(character) {\n        if (!isPermanent && character === \"\\\\\") {\n            isPermanent = true;\n        } else {\n            if (isPermanent || !formatChars[character]) {\n                permanents.push(parsedMaskString.length);\n                if (parsedMaskString.length === permanents.length - 1) {\n                    prefix += character;\n                }\n            } else {\n                lastEditablePosition = parsedMaskString.length + 1;\n            }\n            parsedMaskString += character;\n            isPermanent = false;\n        }\n    });\n    return {\n        maskChar: maskChar,\n        formatChars: formatChars,\n        prefix: prefix,\n        mask: parsedMaskString,\n        lastEditablePosition: lastEditablePosition,\n        permanents: permanents\n    };\n}\n/* eslint no-use-before-define: [\"error\", { functions: false }] */ function isPermanentCharacter(maskOptions, pos) {\n    return maskOptions.permanents.indexOf(pos) !== -1;\n}\nfunction isAllowedCharacter(maskOptions, pos, character) {\n    var mask = maskOptions.mask, formatChars = maskOptions.formatChars;\n    if (!character) {\n        return false;\n    }\n    if (isPermanentCharacter(maskOptions, pos)) {\n        return mask[pos] === character;\n    }\n    var ruleChar = mask[pos];\n    var charRule = formatChars[ruleChar];\n    return new RegExp(charRule).test(character);\n}\nfunction isEmpty(maskOptions, value) {\n    return value.split(\"\").every(function(character, i) {\n        return isPermanentCharacter(maskOptions, i) || !isAllowedCharacter(maskOptions, i, character);\n    });\n}\nfunction getFilledLength(maskOptions, value) {\n    var maskChar = maskOptions.maskChar, prefix = maskOptions.prefix;\n    if (!maskChar) {\n        while(value.length > prefix.length && isPermanentCharacter(maskOptions, value.length - 1)){\n            value = value.slice(0, value.length - 1);\n        }\n        return value.length;\n    }\n    var filledLength = prefix.length;\n    for(var i = value.length; i >= prefix.length; i--){\n        var character = value[i];\n        var isEnteredCharacter = !isPermanentCharacter(maskOptions, i) && isAllowedCharacter(maskOptions, i, character);\n        if (isEnteredCharacter) {\n            filledLength = i + 1;\n            break;\n        }\n    }\n    return filledLength;\n}\nfunction isFilled(maskOptions, value) {\n    return getFilledLength(maskOptions, value) === maskOptions.mask.length;\n}\nfunction formatValue(maskOptions, value) {\n    var maskChar = maskOptions.maskChar, mask = maskOptions.mask, prefix = maskOptions.prefix;\n    if (!maskChar) {\n        value = insertString(maskOptions, \"\", value, 0);\n        if (value.length < prefix.length) {\n            value = prefix;\n        }\n        while(value.length < mask.length && isPermanentCharacter(maskOptions, value.length)){\n            value += mask[value.length];\n        }\n        return value;\n    }\n    if (value) {\n        var emptyValue = formatValue(maskOptions, \"\");\n        return insertString(maskOptions, emptyValue, value, 0);\n    }\n    for(var i = 0; i < mask.length; i++){\n        if (isPermanentCharacter(maskOptions, i)) {\n            value += mask[i];\n        } else {\n            value += maskChar;\n        }\n    }\n    return value;\n}\nfunction clearRange(maskOptions, value, start, len) {\n    var end = start + len;\n    var maskChar = maskOptions.maskChar, mask = maskOptions.mask, prefix = maskOptions.prefix;\n    var arrayValue = value.split(\"\");\n    if (!maskChar) {\n        // remove any permanent chars after clear range, they will be added back by formatValue\n        for(var i = end; i < arrayValue.length; i++){\n            if (isPermanentCharacter(maskOptions, i)) {\n                arrayValue[i] = \"\";\n            }\n        }\n        start = Math.max(prefix.length, start);\n        arrayValue.splice(start, end - start);\n        value = arrayValue.join(\"\");\n        return formatValue(maskOptions, value);\n    }\n    return arrayValue.map(function(character, i) {\n        if (i < start || i >= end) {\n            return character;\n        }\n        if (isPermanentCharacter(maskOptions, i)) {\n            return mask[i];\n        }\n        return maskChar;\n    }).join(\"\");\n}\nfunction insertString(maskOptions, value, insertStr, insertPosition) {\n    var mask = maskOptions.mask, maskChar = maskOptions.maskChar, prefix = maskOptions.prefix;\n    var arrayInsertStr = insertStr.split(\"\");\n    var isInputFilled = isFilled(maskOptions, value);\n    var isUsablePosition = function isUsablePosition(pos, character) {\n        return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];\n    };\n    var isUsableCharacter = function isUsableCharacter(character, pos) {\n        return !maskChar || !isPermanentCharacter(maskOptions, pos) || character !== maskChar;\n    };\n    if (!maskChar && insertPosition > value.length) {\n        value += mask.slice(value.length, insertPosition);\n    }\n    arrayInsertStr.every(function(insertCharacter) {\n        while(!isUsablePosition(insertPosition, insertCharacter)){\n            if (insertPosition >= value.length) {\n                value += mask[insertPosition];\n            }\n            if (!isUsableCharacter(insertCharacter, insertPosition)) {\n                return true;\n            }\n            insertPosition++; // stop iteration if maximum value length reached\n            if (insertPosition >= mask.length) {\n                return false;\n            }\n        }\n        var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;\n        if (!isAllowed) {\n            return true;\n        }\n        if (insertPosition < value.length) {\n            if (maskChar || isInputFilled || insertPosition < prefix.length) {\n                value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition + 1);\n            } else {\n                value = value.slice(0, insertPosition) + insertCharacter + value.slice(insertPosition);\n                value = formatValue(maskOptions, value);\n            }\n        } else if (!maskChar) {\n            value += insertCharacter;\n        }\n        insertPosition++; // stop iteration if maximum value length reached\n        return insertPosition < mask.length;\n    });\n    return value;\n}\nfunction getInsertStringLength(maskOptions, value, insertStr, insertPosition) {\n    var mask = maskOptions.mask, maskChar = maskOptions.maskChar;\n    var arrayInsertStr = insertStr.split(\"\");\n    var initialInsertPosition = insertPosition;\n    var isUsablePosition = function isUsablePosition(pos, character) {\n        return !isPermanentCharacter(maskOptions, pos) || character === mask[pos];\n    };\n    arrayInsertStr.every(function(insertCharacter) {\n        while(!isUsablePosition(insertPosition, insertCharacter)){\n            insertPosition++; // stop iteration if maximum value length reached\n            if (insertPosition >= mask.length) {\n                return false;\n            }\n        }\n        var isAllowed = isAllowedCharacter(maskOptions, insertPosition, insertCharacter) || insertCharacter === maskChar;\n        if (isAllowed) {\n            insertPosition++;\n        } // stop iteration if maximum value length reached\n        return insertPosition < mask.length;\n    });\n    return insertPosition - initialInsertPosition;\n}\nfunction getLeftEditablePosition(maskOptions, pos) {\n    for(var i = pos; i >= 0; --i){\n        if (!isPermanentCharacter(maskOptions, i)) {\n            return i;\n        }\n    }\n    return null;\n}\nfunction getRightEditablePosition(maskOptions, pos) {\n    var mask = maskOptions.mask;\n    for(var i = pos; i < mask.length; ++i){\n        if (!isPermanentCharacter(maskOptions, i)) {\n            return i;\n        }\n    }\n    return null;\n}\nfunction getStringValue(value) {\n    return !value && value !== 0 ? \"\" : value + \"\";\n}\nfunction processChange(maskOptions, value, selection, previousValue, previousSelection) {\n    var mask = maskOptions.mask, prefix = maskOptions.prefix, lastEditablePosition = maskOptions.lastEditablePosition;\n    var newValue = value;\n    var enteredString = \"\";\n    var formattedEnteredStringLength = 0;\n    var removedLength = 0;\n    var cursorPosition = Math.min(previousSelection.start, selection.start);\n    if (selection.end > previousSelection.start) {\n        enteredString = newValue.slice(previousSelection.start, selection.end);\n        formattedEnteredStringLength = getInsertStringLength(maskOptions, previousValue, enteredString, cursorPosition);\n        if (!formattedEnteredStringLength) {\n            removedLength = 0;\n        } else {\n            removedLength = previousSelection.length;\n        }\n    } else if (newValue.length < previousValue.length) {\n        removedLength = previousValue.length - newValue.length;\n    }\n    newValue = previousValue;\n    if (removedLength) {\n        if (removedLength === 1 && !previousSelection.length) {\n            var deleteFromRight = previousSelection.start === selection.start;\n            cursorPosition = deleteFromRight ? getRightEditablePosition(maskOptions, selection.start) : getLeftEditablePosition(maskOptions, selection.start);\n        }\n        newValue = clearRange(maskOptions, newValue, cursorPosition, removedLength);\n    }\n    newValue = insertString(maskOptions, newValue, enteredString, cursorPosition);\n    cursorPosition = cursorPosition + formattedEnteredStringLength;\n    if (cursorPosition >= mask.length) {\n        cursorPosition = mask.length;\n    } else if (cursorPosition < prefix.length && !formattedEnteredStringLength) {\n        cursorPosition = prefix.length;\n    } else if (cursorPosition >= prefix.length && cursorPosition < lastEditablePosition && formattedEnteredStringLength) {\n        cursorPosition = getRightEditablePosition(maskOptions, cursorPosition);\n    }\n    newValue = formatValue(maskOptions, newValue);\n    if (!enteredString) {\n        enteredString = null;\n    }\n    return {\n        value: newValue,\n        enteredString: enteredString,\n        selection: {\n            start: cursorPosition,\n            end: cursorPosition\n        }\n    };\n}\nfunction isWindowsPhoneBrowser() {\n    var windows = new RegExp(\"windows\", \"i\");\n    var phone = new RegExp(\"phone\", \"i\");\n    var ua = navigator.userAgent;\n    return windows.test(ua) && phone.test(ua);\n}\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nfunction getRequestAnimationFrame() {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n}\nfunction getCancelAnimationFrame() {\n    return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame;\n}\nfunction defer(fn) {\n    var hasCancelAnimationFrame = !!getCancelAnimationFrame();\n    var deferFn;\n    if (hasCancelAnimationFrame) {\n        deferFn = getRequestAnimationFrame();\n    } else {\n        deferFn = function deferFn() {\n            return setTimeout(fn, 1000 / 60);\n        };\n    }\n    return deferFn(fn);\n}\nfunction cancelDefer(deferId) {\n    var cancelFn = getCancelAnimationFrame() || clearTimeout;\n    cancelFn(deferId);\n}\nvar InputElement = /*#__PURE__*/ function(_React$Component) {\n    _inheritsLoose(InputElement, _React$Component);\n    function InputElement(props) {\n        var _this;\n        _this = _React$Component.call(this, props) || this;\n        _this.focused = false;\n        _this.mounted = false;\n        _this.previousSelection = null;\n        _this.selectionDeferId = null;\n        _this.saveSelectionLoopDeferId = null;\n        _this.saveSelectionLoop = function() {\n            _this.previousSelection = _this.getSelection();\n            _this.saveSelectionLoopDeferId = defer(_this.saveSelectionLoop);\n        };\n        _this.runSaveSelectionLoop = function() {\n            if (_this.saveSelectionLoopDeferId === null) {\n                _this.saveSelectionLoop();\n            }\n        };\n        _this.stopSaveSelectionLoop = function() {\n            if (_this.saveSelectionLoopDeferId !== null) {\n                cancelDefer(_this.saveSelectionLoopDeferId);\n                _this.saveSelectionLoopDeferId = null;\n                _this.previousSelection = null;\n            }\n        };\n        _this.getInputDOMNode = function() {\n            if (!_this.mounted) {\n                return null;\n            }\n            var input = reactDom.findDOMNode(_assertThisInitialized(_assertThisInitialized(_this)));\n            var isDOMNode =  false && 0; // workaround for react-test-renderer\n            // https://github.com/sanniassin/react-input-mask/issues/147\n            if (input && !isDOMNode) {\n                return null;\n            }\n            if (input.nodeName !== \"INPUT\") {\n                input = input.querySelector(\"input\");\n            }\n            if (!input) {\n                throw new Error(\"react-input-mask: inputComponent doesn't contain input node\");\n            }\n            return input;\n        };\n        _this.getInputValue = function() {\n            var input = _this.getInputDOMNode();\n            if (!input) {\n                return null;\n            }\n            return input.value;\n        };\n        _this.setInputValue = function(value) {\n            var input = _this.getInputDOMNode();\n            if (!input) {\n                return;\n            }\n            _this.value = value;\n            input.value = value;\n        };\n        _this.setCursorToEnd = function() {\n            var filledLength = getFilledLength(_this.maskOptions, _this.value);\n            var pos = getRightEditablePosition(_this.maskOptions, filledLength);\n            if (pos !== null) {\n                _this.setCursorPosition(pos);\n            }\n        };\n        _this.setSelection = function(start, end, options) {\n            if (options === void 0) {\n                options = {};\n            }\n            var input = _this.getInputDOMNode();\n            var isFocused = _this.isFocused(); // don't change selection on unfocused input\n            // because Safari sets focus on selection change (#154)\n            if (!input || !isFocused) {\n                return;\n            }\n            var _options = options, deferred = _options.deferred;\n            if (!deferred) {\n                setInputSelection(input, start, end);\n            }\n            if (_this.selectionDeferId !== null) {\n                cancelDefer(_this.selectionDeferId);\n            } // deferred selection update is required for pre-Lollipop Android browser,\n            // but for consistent behavior we do it for all browsers\n            _this.selectionDeferId = defer(function() {\n                _this.selectionDeferId = null;\n                setInputSelection(input, start, end);\n            });\n            _this.previousSelection = {\n                start: start,\n                end: end,\n                length: Math.abs(end - start)\n            };\n        };\n        _this.getSelection = function() {\n            var input = _this.getInputDOMNode();\n            return getInputSelection(input);\n        };\n        _this.getCursorPosition = function() {\n            return _this.getSelection().start;\n        };\n        _this.setCursorPosition = function(pos) {\n            _this.setSelection(pos, pos);\n        };\n        _this.isFocused = function() {\n            return _this.focused;\n        };\n        _this.getBeforeMaskedValueChangeConfig = function() {\n            var _this$maskOptions = _this.maskOptions, mask = _this$maskOptions.mask, maskChar = _this$maskOptions.maskChar, permanents = _this$maskOptions.permanents, formatChars = _this$maskOptions.formatChars;\n            var alwaysShowMask = _this.props.alwaysShowMask;\n            return {\n                mask: mask,\n                maskChar: maskChar,\n                permanents: permanents,\n                alwaysShowMask: !!alwaysShowMask,\n                formatChars: formatChars\n            };\n        };\n        _this.isInputAutofilled = function(value, selection, previousValue, previousSelection) {\n            var input = _this.getInputDOMNode(); // only check for positive match because it will be false negative\n            // in case of autofill simulation in tests\n            //\n            // input.matches throws an exception if selector isn't supported\n            try {\n                if (input.matches(\":-webkit-autofill\")) {\n                    return true;\n                }\n            } catch (e) {} // if input isn't focused then change event must have been triggered\n            // either by autofill or event simulation in tests\n            if (!_this.focused) {\n                return true;\n            } // if cursor has moved to the end while previousSelection forbids it\n            // then it must be autofill\n            return previousSelection.end < previousValue.length && selection.end === value.length;\n        };\n        _this.onChange = function(event) {\n            var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)), beforePasteState = _assertThisInitialize.beforePasteState;\n            var _assertThisInitialize2 = _assertThisInitialized(_assertThisInitialized(_this)), previousSelection = _assertThisInitialize2.previousSelection;\n            var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;\n            var value = _this.getInputValue();\n            var previousValue = _this.value;\n            var selection = _this.getSelection(); // autofill replaces entire value, ignore old one\n            // https://github.com/sanniassin/react-input-mask/issues/113\n            if (_this.isInputAutofilled(value, selection, previousValue, previousSelection)) {\n                previousValue = formatValue(_this.maskOptions, \"\");\n                previousSelection = {\n                    start: 0,\n                    end: 0,\n                    length: 0\n                };\n            } // set value and selection as if we haven't\n            // cleared input in onPaste handler\n            if (beforePasteState) {\n                previousSelection = beforePasteState.selection;\n                previousValue = beforePasteState.value;\n                selection = {\n                    start: previousSelection.start + value.length,\n                    end: previousSelection.start + value.length,\n                    length: 0\n                };\n                value = previousValue.slice(0, previousSelection.start) + value + previousValue.slice(previousSelection.end);\n                _this.beforePasteState = null;\n            }\n            var changedState = processChange(_this.maskOptions, value, selection, previousValue, previousSelection);\n            var enteredString = changedState.enteredString;\n            var newSelection = changedState.selection;\n            var newValue = changedState.value;\n            if (isFunction(beforeMaskedValueChange)) {\n                var modifiedValue = beforeMaskedValueChange({\n                    value: newValue,\n                    selection: newSelection\n                }, {\n                    value: previousValue,\n                    selection: previousSelection\n                }, enteredString, _this.getBeforeMaskedValueChangeConfig());\n                newValue = modifiedValue.value;\n                newSelection = modifiedValue.selection;\n            }\n            _this.setInputValue(newValue);\n            if (isFunction(_this.props.onChange)) {\n                _this.props.onChange(event);\n            }\n            if (_this.isWindowsPhoneBrowser) {\n                _this.setSelection(newSelection.start, newSelection.end, {\n                    deferred: true\n                });\n            } else {\n                _this.setSelection(newSelection.start, newSelection.end);\n            }\n        };\n        _this.onFocus = function(event) {\n            var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;\n            var _this$maskOptions2 = _this.maskOptions, mask = _this$maskOptions2.mask, prefix = _this$maskOptions2.prefix;\n            _this.focused = true; // if autoFocus is set, onFocus triggers before componentDidMount\n            _this.mounted = true;\n            if (mask) {\n                if (!_this.value) {\n                    var emptyValue = formatValue(_this.maskOptions, prefix);\n                    var newValue = formatValue(_this.maskOptions, emptyValue);\n                    var filledLength = getFilledLength(_this.maskOptions, newValue);\n                    var cursorPosition = getRightEditablePosition(_this.maskOptions, filledLength);\n                    var newSelection = {\n                        start: cursorPosition,\n                        end: cursorPosition\n                    };\n                    if (isFunction(beforeMaskedValueChange)) {\n                        var modifiedValue = beforeMaskedValueChange({\n                            value: newValue,\n                            selection: newSelection\n                        }, {\n                            value: _this.value,\n                            selection: null\n                        }, null, _this.getBeforeMaskedValueChangeConfig());\n                        newValue = modifiedValue.value;\n                        newSelection = modifiedValue.selection;\n                    }\n                    var isInputValueChanged = newValue !== _this.getInputValue();\n                    if (isInputValueChanged) {\n                        _this.setInputValue(newValue);\n                    }\n                    if (isInputValueChanged && isFunction(_this.props.onChange)) {\n                        _this.props.onChange(event);\n                    }\n                    _this.setSelection(newSelection.start, newSelection.end);\n                } else if (getFilledLength(_this.maskOptions, _this.value) < _this.maskOptions.mask.length) {\n                    _this.setCursorToEnd();\n                }\n                _this.runSaveSelectionLoop();\n            }\n            if (isFunction(_this.props.onFocus)) {\n                _this.props.onFocus(event);\n            }\n        };\n        _this.onBlur = function(event) {\n            var beforeMaskedValueChange = _this.props.beforeMaskedValueChange;\n            var mask = _this.maskOptions.mask;\n            _this.stopSaveSelectionLoop();\n            _this.focused = false;\n            if (mask && !_this.props.alwaysShowMask && isEmpty(_this.maskOptions, _this.value)) {\n                var newValue = \"\";\n                if (isFunction(beforeMaskedValueChange)) {\n                    var modifiedValue = beforeMaskedValueChange({\n                        value: newValue,\n                        selection: null\n                    }, {\n                        value: _this.value,\n                        selection: _this.previousSelection\n                    }, null, _this.getBeforeMaskedValueChangeConfig());\n                    newValue = modifiedValue.value;\n                }\n                var isInputValueChanged = newValue !== _this.getInputValue();\n                if (isInputValueChanged) {\n                    _this.setInputValue(newValue);\n                }\n                if (isInputValueChanged && isFunction(_this.props.onChange)) {\n                    _this.props.onChange(event);\n                }\n            }\n            if (isFunction(_this.props.onBlur)) {\n                _this.props.onBlur(event);\n            }\n        };\n        _this.onMouseDown = function(event) {\n            // tiny unintentional mouse movements can break cursor\n            // position on focus, so we have to restore it in that case\n            //\n            // https://github.com/sanniassin/react-input-mask/issues/108\n            if (!_this.focused && document.addEventListener) {\n                _this.mouseDownX = event.clientX;\n                _this.mouseDownY = event.clientY;\n                _this.mouseDownTime = new Date().getTime();\n                var mouseUpHandler = function mouseUpHandler(mouseUpEvent) {\n                    document.removeEventListener(\"mouseup\", mouseUpHandler);\n                    if (!_this.focused) {\n                        return;\n                    }\n                    var deltaX = Math.abs(mouseUpEvent.clientX - _this.mouseDownX);\n                    var deltaY = Math.abs(mouseUpEvent.clientY - _this.mouseDownY);\n                    var axisDelta = Math.max(deltaX, deltaY);\n                    var timeDelta = new Date().getTime() - _this.mouseDownTime;\n                    if (axisDelta <= 10 && timeDelta <= 200 || axisDelta <= 5 && timeDelta <= 300) {\n                        _this.setCursorToEnd();\n                    }\n                };\n                document.addEventListener(\"mouseup\", mouseUpHandler);\n            }\n            if (isFunction(_this.props.onMouseDown)) {\n                _this.props.onMouseDown(event);\n            }\n        };\n        _this.onPaste = function(event) {\n            if (isFunction(_this.props.onPaste)) {\n                _this.props.onPaste(event);\n            } // event.clipboardData might not work in Android browser\n            // cleaning input to get raw text inside onChange handler\n            if (!event.defaultPrevented) {\n                _this.beforePasteState = {\n                    value: _this.getInputValue(),\n                    selection: _this.getSelection()\n                };\n                _this.setInputValue(\"\");\n            }\n        };\n        _this.handleRef = function(ref) {\n            if (_this.props.children == null && isFunction(_this.props.inputRef)) {\n                _this.props.inputRef(ref);\n            }\n        };\n        var _mask = props.mask, _maskChar = props.maskChar, _formatChars = props.formatChars, _alwaysShowMask = props.alwaysShowMask, _beforeMaskedValueChange = props.beforeMaskedValueChange;\n        var defaultValue = props.defaultValue, _value = props.value;\n        _this.maskOptions = parseMask(_mask, _maskChar, _formatChars);\n        if (defaultValue == null) {\n            defaultValue = \"\";\n        }\n        if (_value == null) {\n            _value = defaultValue;\n        }\n        var _newValue = getStringValue(_value);\n        if (_this.maskOptions.mask && (_alwaysShowMask || _newValue)) {\n            _newValue = formatValue(_this.maskOptions, _newValue);\n            if (isFunction(_beforeMaskedValueChange)) {\n                var oldValue = props.value;\n                if (props.value == null) {\n                    oldValue = defaultValue;\n                }\n                oldValue = getStringValue(oldValue);\n                var modifiedValue = _beforeMaskedValueChange({\n                    value: _newValue,\n                    selection: null\n                }, {\n                    value: oldValue,\n                    selection: null\n                }, null, _this.getBeforeMaskedValueChangeConfig());\n                _newValue = modifiedValue.value;\n            }\n        }\n        _this.value = _newValue;\n        return _this;\n    }\n    var _proto = InputElement.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n        this.mounted = true; // workaround for react-test-renderer\n        // https://github.com/sanniassin/react-input-mask/issues/147\n        if (!this.getInputDOMNode()) {\n            return;\n        }\n        this.isWindowsPhoneBrowser = isWindowsPhoneBrowser();\n        if (this.maskOptions.mask && this.getInputValue() !== this.value) {\n            this.setInputValue(this.value);\n        }\n    };\n    _proto.componentDidUpdate = function componentDidUpdate() {\n        var previousSelection = this.previousSelection;\n        var _this$props = this.props, beforeMaskedValueChange = _this$props.beforeMaskedValueChange, alwaysShowMask = _this$props.alwaysShowMask, mask = _this$props.mask, maskChar = _this$props.maskChar, formatChars = _this$props.formatChars;\n        var previousMaskOptions = this.maskOptions;\n        var showEmpty = alwaysShowMask || this.isFocused();\n        var hasValue = this.props.value != null;\n        var newValue = hasValue ? getStringValue(this.props.value) : this.value;\n        var cursorPosition = previousSelection ? previousSelection.start : null;\n        this.maskOptions = parseMask(mask, maskChar, formatChars);\n        if (!this.maskOptions.mask) {\n            if (previousMaskOptions.mask) {\n                this.stopSaveSelectionLoop(); // render depends on this.maskOptions and this.value,\n                // call forceUpdate to keep it in sync\n                this.forceUpdate();\n            }\n            return;\n        } else if (!previousMaskOptions.mask && this.isFocused()) {\n            this.runSaveSelectionLoop();\n        }\n        var isMaskChanged = this.maskOptions.mask && this.maskOptions.mask !== previousMaskOptions.mask;\n        if (!previousMaskOptions.mask && !hasValue) {\n            newValue = this.getInputValue();\n        }\n        if (isMaskChanged || this.maskOptions.mask && (newValue || showEmpty)) {\n            newValue = formatValue(this.maskOptions, newValue);\n        }\n        if (isMaskChanged) {\n            var filledLength = getFilledLength(this.maskOptions, newValue);\n            if (cursorPosition === null || filledLength < cursorPosition) {\n                if (isFilled(this.maskOptions, newValue)) {\n                    cursorPosition = filledLength;\n                } else {\n                    cursorPosition = getRightEditablePosition(this.maskOptions, filledLength);\n                }\n            }\n        }\n        if (this.maskOptions.mask && isEmpty(this.maskOptions, newValue) && !showEmpty && (!hasValue || !this.props.value)) {\n            newValue = \"\";\n        }\n        var newSelection = {\n            start: cursorPosition,\n            end: cursorPosition\n        };\n        if (isFunction(beforeMaskedValueChange)) {\n            var modifiedValue = beforeMaskedValueChange({\n                value: newValue,\n                selection: newSelection\n            }, {\n                value: this.value,\n                selection: this.previousSelection\n            }, null, this.getBeforeMaskedValueChangeConfig());\n            newValue = modifiedValue.value;\n            newSelection = modifiedValue.selection;\n        }\n        this.value = newValue;\n        var isValueChanged = this.getInputValue() !== this.value; // render depends on this.maskOptions and this.value,\n        // call forceUpdate to keep it in sync\n        if (isValueChanged) {\n            this.setInputValue(this.value);\n            this.forceUpdate();\n        } else if (isMaskChanged) {\n            this.forceUpdate();\n        }\n        var isSelectionChanged = false;\n        if (newSelection.start != null && newSelection.end != null) {\n            isSelectionChanged = !previousSelection || previousSelection.start !== newSelection.start || previousSelection.end !== newSelection.end;\n        }\n        if (isSelectionChanged || isValueChanged) {\n            this.setSelection(newSelection.start, newSelection.end);\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.mounted = false;\n        if (this.selectionDeferId !== null) {\n            cancelDefer(this.selectionDeferId);\n        }\n        this.stopSaveSelectionLoop();\n    };\n    _proto.render = function render() {\n        var _this$props2 = this.props, mask = _this$props2.mask, alwaysShowMask = _this$props2.alwaysShowMask, maskChar = _this$props2.maskChar, formatChars = _this$props2.formatChars, inputRef = _this$props2.inputRef, beforeMaskedValueChange = _this$props2.beforeMaskedValueChange, children = _this$props2.children, restProps = _objectWithoutPropertiesLoose(_this$props2, [\n            \"mask\",\n            \"alwaysShowMask\",\n            \"maskChar\",\n            \"formatChars\",\n            \"inputRef\",\n            \"beforeMaskedValueChange\",\n            \"children\"\n        ]);\n        var inputElement;\n         true ? warning(// will be updated later in componentDidUpdate\n        !restProps.maxLength || !parseMask(mask, maskChar, formatChars).mask, \"react-input-mask: maxLength property shouldn't be passed to the masked input. It breaks masking and unnecessary because length is limited by the mask length.\") : 0;\n        if (children) {\n            !isFunction(children) ?  true ? invariant(false, \"react-input-mask: children must be a function\") : 0 : void 0;\n            var controlledProps = [\n                \"onChange\",\n                \"onPaste\",\n                \"onMouseDown\",\n                \"onFocus\",\n                \"onBlur\",\n                \"value\",\n                \"disabled\",\n                \"readOnly\"\n            ];\n            var childrenProps = _extends({}, restProps);\n            controlledProps.forEach(function(propId) {\n                return delete childrenProps[propId];\n            });\n            inputElement = children(childrenProps);\n            var conflictProps = controlledProps.filter(function(propId) {\n                return inputElement.props[propId] != null && inputElement.props[propId] !== restProps[propId];\n            });\n            !!conflictProps.length ?  true ? invariant(false, \"react-input-mask: the following props should be passed to the react-input-mask's component and should not be altered in children's function: \" + conflictProps.join(\", \")) : 0 : void 0;\n             true ? warning(!inputRef, \"react-input-mask: inputRef is ignored when children is passed, attach ref to the children instead\") : 0;\n        } else {\n            inputElement = React.createElement(\"input\", _extends({\n                ref: this.handleRef\n            }, restProps));\n        }\n        var changedProps = {\n            onFocus: this.onFocus,\n            onBlur: this.onBlur\n        };\n        if (this.maskOptions.mask) {\n            if (!restProps.disabled && !restProps.readOnly) {\n                changedProps.onChange = this.onChange;\n                changedProps.onPaste = this.onPaste;\n                changedProps.onMouseDown = this.onMouseDown;\n            }\n            if (restProps.value != null) {\n                changedProps.value = this.value;\n            }\n        }\n        inputElement = React.cloneElement(inputElement, changedProps);\n        return inputElement;\n    };\n    return InputElement;\n}(React.Component);\nmodule.exports = InputElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9saWIvcmVhY3QtaW5wdXQtbWFzay5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLFNBQVNBLGdCQUFpQkMsRUFBRTtJQUFJLE9BQU8sTUFBUSxPQUFPQSxPQUFPLFlBQWEsYUFBYUEsS0FBTUEsRUFBRSxDQUFDLFVBQVUsR0FBR0E7QUFBSTtBQUVqSCxJQUFJQyxRQUFRRixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3BDLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLFlBQVlMLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDeEMsSUFBSUcsVUFBVU4sZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUV0QyxTQUFTSSxXQUFXQyxHQUFHLEVBQUVDLFFBQVE7SUFBSSxJQUFJQyxPQUFPQyxPQUFPQyxtQkFBbUIsQ0FBQ0g7SUFBVyxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUgsS0FBS0ksTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSUUsTUFBTUwsSUFBSSxDQUFDRyxFQUFFO1FBQUUsSUFBSUcsUUFBUUwsT0FBT00sd0JBQXdCLENBQUNSLFVBQVVNO1FBQU0sSUFBSUMsU0FBU0EsTUFBTUUsWUFBWSxJQUFJVixHQUFHLENBQUNPLElBQUksS0FBS0ksV0FBVztZQUFFUixPQUFPUyxjQUFjLENBQUNaLEtBQUtPLEtBQUtDO1FBQVE7SUFBRTtJQUFFLE9BQU9SO0FBQUs7QUFFbFUsU0FBU2E7SUFDUEEsV0FBV1YsT0FBT1csTUFBTSxJQUFJLFNBQVVDLE1BQU07UUFDMUMsSUFBSyxJQUFJVixJQUFJLEdBQUdBLElBQUlXLFVBQVVWLE1BQU0sRUFBRUQsSUFBSztZQUN6QyxJQUFJWSxTQUFTRCxTQUFTLENBQUNYLEVBQUU7WUFFekIsSUFBSyxJQUFJRSxPQUFPVSxPQUFRO2dCQUN0QixJQUFJZCxPQUFPZSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxRQUFRVixN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QzlDRixhQUFhcEUsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtnQkFDckNvRSxhQUFhdkMsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTztnQkFDbkN1QyxhQUFhdkQsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVztZQUM3QztZQUVBLElBQUk2QyxVQUFVbk8sS0FBSyxJQUFJLE1BQU07Z0JBQzNCNk8sYUFBYTdPLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUs7WUFDakM7UUFDRjtRQUVBb08sZUFBZWxQLE1BQU04UCxZQUFZLENBQUNaLGNBQWNTO1FBQ2hELE9BQU9UO0lBQ1Q7SUFFQSxPQUFPL0Y7QUFDVCxFQUFFbkosTUFBTStQLFNBQVM7QUFFakJDLE9BQU9DLE9BQU8sR0FBRzlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWJkdWxheml6LXByb2dyYW1tZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5wdXQtbWFzay9saWIvcmVhY3QtaW5wdXQtbWFzay5kZXZlbG9wbWVudC5qcz9kNmZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBSZWFjdCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFjdCcpKTtcbnZhciByZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIGludmFyaWFudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdpbnZhcmlhbnQnKSk7XG52YXIgd2FybmluZyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd3YXJuaW5nJykpO1xuXG5mdW5jdGlvbiBfZGVmYXVsdHMyKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX2RlZmF1bHRzMihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBzZXRJbnB1dFNlbGVjdGlvbihpbnB1dCwgc3RhcnQsIGVuZCkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCAmJiAnc2VsZWN0aW9uRW5kJyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICB9IGVsc2Uge1xuICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICByYW5nZS5zZWxlY3QoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQgJiYgJ3NlbGVjdGlvbkVuZCcgaW4gaW5wdXQpIHtcbiAgICBzdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgIGVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcblxuICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICBzdGFydCA9IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgICAgZW5kID0gLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICAgIGxlbmd0aDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxudmFyIGRlZmF1bHRGb3JtYXRDaGFycyA9IHtcbiAgJzknOiAnWzAtOV0nLFxuICAnYSc6ICdbQS1aYS16XScsXG4gICcqJzogJ1tBLVphLXowLTldJ1xufTtcbnZhciBkZWZhdWx0TWFza0NoYXIgPSAnXyc7XG5cbmZ1bmN0aW9uIHBhcnNlTWFzayAobWFzaywgbWFza0NoYXIsIGZvcm1hdENoYXJzKSB7XG4gIHZhciBwYXJzZWRNYXNrU3RyaW5nID0gJyc7XG4gIHZhciBwcmVmaXggPSAnJztcbiAgdmFyIGxhc3RFZGl0YWJsZVBvc2l0aW9uID0gbnVsbDtcbiAgdmFyIHBlcm1hbmVudHMgPSBbXTtcblxuICBpZiAobWFza0NoYXIgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hc2tDaGFyID0gZGVmYXVsdE1hc2tDaGFyO1xuICB9XG5cbiAgaWYgKGZvcm1hdENoYXJzID09IG51bGwpIHtcbiAgICBmb3JtYXRDaGFycyA9IGRlZmF1bHRGb3JtYXRDaGFycztcbiAgfVxuXG4gIGlmICghbWFzayB8fCB0eXBlb2YgbWFzayAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFza0NoYXI6IG1hc2tDaGFyLFxuICAgICAgZm9ybWF0Q2hhcnM6IGZvcm1hdENoYXJzLFxuICAgICAgbWFzazogbnVsbCxcbiAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uOiBudWxsLFxuICAgICAgcGVybWFuZW50czogW11cbiAgICB9O1xuICB9XG5cbiAgdmFyIGlzUGVybWFuZW50ID0gZmFsc2U7XG4gIG1hc2suc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuICAgIGlmICghaXNQZXJtYW5lbnQgJiYgY2hhcmFjdGVyID09PSAnXFxcXCcpIHtcbiAgICAgIGlzUGVybWFuZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUGVybWFuZW50IHx8ICFmb3JtYXRDaGFyc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgIHBlcm1hbmVudHMucHVzaChwYXJzZWRNYXNrU3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHBhcnNlZE1hc2tTdHJpbmcubGVuZ3RoID09PSBwZXJtYW5lbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBwcmVmaXggKz0gY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0RWRpdGFibGVQb3NpdGlvbiA9IHBhcnNlZE1hc2tTdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VkTWFza1N0cmluZyArPSBjaGFyYWN0ZXI7XG4gICAgICBpc1Blcm1hbmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbWFza0NoYXI6IG1hc2tDaGFyLFxuICAgIGZvcm1hdENoYXJzOiBmb3JtYXRDaGFycyxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBtYXNrOiBwYXJzZWRNYXNrU3RyaW5nLFxuICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uOiBsYXN0RWRpdGFibGVQb3NpdGlvbixcbiAgICBwZXJtYW5lbnRzOiBwZXJtYW5lbnRzXG4gIH07XG59XG5cbi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogW1wiZXJyb3JcIiwgeyBmdW5jdGlvbnM6IGZhbHNlIH1dICovXG5mdW5jdGlvbiBpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgcG9zKSB7XG4gIHJldHVybiBtYXNrT3B0aW9ucy5wZXJtYW5lbnRzLmluZGV4T2YocG9zKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBpc0FsbG93ZWRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHBvcywgY2hhcmFjdGVyKSB7XG4gIHZhciBtYXNrID0gbWFza09wdGlvbnMubWFzayxcbiAgICAgIGZvcm1hdENoYXJzID0gbWFza09wdGlvbnMuZm9ybWF0Q2hhcnM7XG5cbiAgaWYgKCFjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHBvcykpIHtcbiAgICByZXR1cm4gbWFza1twb3NdID09PSBjaGFyYWN0ZXI7XG4gIH1cblxuICB2YXIgcnVsZUNoYXIgPSBtYXNrW3Bvc107XG4gIHZhciBjaGFyUnVsZSA9IGZvcm1hdENoYXJzW3J1bGVDaGFyXTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoY2hhclJ1bGUpLnRlc3QoY2hhcmFjdGVyKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkobWFza09wdGlvbnMsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgnJykuZXZlcnkoZnVuY3Rpb24gKGNoYXJhY3RlciwgaSkge1xuICAgIHJldHVybiBpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSkgfHwgIWlzQWxsb3dlZENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSwgY2hhcmFjdGVyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRGaWxsZWRMZW5ndGgobWFza09wdGlvbnMsIHZhbHVlKSB7XG4gIHZhciBtYXNrQ2hhciA9IG1hc2tPcHRpb25zLm1hc2tDaGFyLFxuICAgICAgcHJlZml4ID0gbWFza09wdGlvbnMucHJlZml4O1xuXG4gIGlmICghbWFza0NoYXIpIHtcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gcHJlZml4Lmxlbmd0aCAmJiBpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgdmFsdWUubGVuZ3RoIC0gMSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBmaWxsZWRMZW5ndGggPSBwcmVmaXgubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSB2YWx1ZS5sZW5ndGg7IGkgPj0gcHJlZml4Lmxlbmd0aDsgaS0tKSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IHZhbHVlW2ldO1xuICAgIHZhciBpc0VudGVyZWRDaGFyYWN0ZXIgPSAhaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpICYmIGlzQWxsb3dlZENoYXJhY3RlcihtYXNrT3B0aW9ucywgaSwgY2hhcmFjdGVyKTtcblxuICAgIGlmIChpc0VudGVyZWRDaGFyYWN0ZXIpIHtcbiAgICAgIGZpbGxlZExlbmd0aCA9IGkgKyAxO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbGxlZExlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzRmlsbGVkKG1hc2tPcHRpb25zLCB2YWx1ZSkge1xuICByZXR1cm4gZ2V0RmlsbGVkTGVuZ3RoKG1hc2tPcHRpb25zLCB2YWx1ZSkgPT09IG1hc2tPcHRpb25zLm1hc2subGVuZ3RoO1xufVxuZnVuY3Rpb24gZm9ybWF0VmFsdWUobWFza09wdGlvbnMsIHZhbHVlKSB7XG4gIHZhciBtYXNrQ2hhciA9IG1hc2tPcHRpb25zLm1hc2tDaGFyLFxuICAgICAgbWFzayA9IG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICBwcmVmaXggPSBtYXNrT3B0aW9ucy5wcmVmaXg7XG5cbiAgaWYgKCFtYXNrQ2hhcikge1xuICAgIHZhbHVlID0gaW5zZXJ0U3RyaW5nKG1hc2tPcHRpb25zLCAnJywgdmFsdWUsIDApO1xuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA8IHByZWZpeC5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gcHJlZml4O1xuICAgIH1cblxuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBtYXNrLmxlbmd0aCAmJiBpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgdmFsdWUubGVuZ3RoKSkge1xuICAgICAgdmFsdWUgKz0gbWFza1t2YWx1ZS5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSkge1xuICAgIHZhciBlbXB0eVZhbHVlID0gZm9ybWF0VmFsdWUobWFza09wdGlvbnMsICcnKTtcbiAgICByZXR1cm4gaW5zZXJ0U3RyaW5nKG1hc2tPcHRpb25zLCBlbXB0eVZhbHVlLCB2YWx1ZSwgMCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hc2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpKSB7XG4gICAgICB2YWx1ZSArPSBtYXNrW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBtYXNrQ2hhcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjbGVhclJhbmdlKG1hc2tPcHRpb25zLCB2YWx1ZSwgc3RhcnQsIGxlbikge1xuICB2YXIgZW5kID0gc3RhcnQgKyBsZW47XG4gIHZhciBtYXNrQ2hhciA9IG1hc2tPcHRpb25zLm1hc2tDaGFyLFxuICAgICAgbWFzayA9IG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICBwcmVmaXggPSBtYXNrT3B0aW9ucy5wcmVmaXg7XG4gIHZhciBhcnJheVZhbHVlID0gdmFsdWUuc3BsaXQoJycpO1xuXG4gIGlmICghbWFza0NoYXIpIHtcbiAgICAvLyByZW1vdmUgYW55IHBlcm1hbmVudCBjaGFycyBhZnRlciBjbGVhciByYW5nZSwgdGhleSB3aWxsIGJlIGFkZGVkIGJhY2sgYnkgZm9ybWF0VmFsdWVcbiAgICBmb3IgKHZhciBpID0gZW5kOyBpIDwgYXJyYXlWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSkge1xuICAgICAgICBhcnJheVZhbHVlW2ldID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnQgPSBNYXRoLm1heChwcmVmaXgubGVuZ3RoLCBzdGFydCk7XG4gICAgYXJyYXlWYWx1ZS5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB2YWx1ZSA9IGFycmF5VmFsdWUuam9pbignJyk7XG4gICAgcmV0dXJuIGZvcm1hdFZhbHVlKG1hc2tPcHRpb25zLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlWYWx1ZS5tYXAoZnVuY3Rpb24gKGNoYXJhY3RlciwgaSkge1xuICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXI7XG4gICAgfVxuXG4gICAgaWYgKGlzUGVybWFuZW50Q2hhcmFjdGVyKG1hc2tPcHRpb25zLCBpKSkge1xuICAgICAgcmV0dXJuIG1hc2tbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2tDaGFyO1xuICB9KS5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGluc2VydFN0cmluZyhtYXNrT3B0aW9ucywgdmFsdWUsIGluc2VydFN0ciwgaW5zZXJ0UG9zaXRpb24pIHtcbiAgdmFyIG1hc2sgPSBtYXNrT3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0NoYXIgPSBtYXNrT3B0aW9ucy5tYXNrQ2hhcixcbiAgICAgIHByZWZpeCA9IG1hc2tPcHRpb25zLnByZWZpeDtcbiAgdmFyIGFycmF5SW5zZXJ0U3RyID0gaW5zZXJ0U3RyLnNwbGl0KCcnKTtcbiAgdmFyIGlzSW5wdXRGaWxsZWQgPSBpc0ZpbGxlZChtYXNrT3B0aW9ucywgdmFsdWUpO1xuXG4gIHZhciBpc1VzYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gaXNVc2FibGVQb3NpdGlvbihwb3MsIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiAhaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIHBvcykgfHwgY2hhcmFjdGVyID09PSBtYXNrW3Bvc107XG4gIH07XG5cbiAgdmFyIGlzVXNhYmxlQ2hhcmFjdGVyID0gZnVuY3Rpb24gaXNVc2FibGVDaGFyYWN0ZXIoY2hhcmFjdGVyLCBwb3MpIHtcbiAgICByZXR1cm4gIW1hc2tDaGFyIHx8ICFpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgcG9zKSB8fCBjaGFyYWN0ZXIgIT09IG1hc2tDaGFyO1xuICB9O1xuXG4gIGlmICghbWFza0NoYXIgJiYgaW5zZXJ0UG9zaXRpb24gPiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSArPSBtYXNrLnNsaWNlKHZhbHVlLmxlbmd0aCwgaW5zZXJ0UG9zaXRpb24pO1xuICB9XG5cbiAgYXJyYXlJbnNlcnRTdHIuZXZlcnkoZnVuY3Rpb24gKGluc2VydENoYXJhY3Rlcikge1xuICAgIHdoaWxlICghaXNVc2FibGVQb3NpdGlvbihpbnNlcnRQb3NpdGlvbiwgaW5zZXJ0Q2hhcmFjdGVyKSkge1xuICAgICAgaWYgKGluc2VydFBvc2l0aW9uID49IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSArPSBtYXNrW2luc2VydFBvc2l0aW9uXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1VzYWJsZUNoYXJhY3RlcihpbnNlcnRDaGFyYWN0ZXIsIGluc2VydFBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0UG9zaXRpb24rKzsgLy8gc3RvcCBpdGVyYXRpb24gaWYgbWF4aW11bSB2YWx1ZSBsZW5ndGggcmVhY2hlZFxuXG4gICAgICBpZiAoaW5zZXJ0UG9zaXRpb24gPj0gbWFzay5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0FsbG93ZWQgPSBpc0FsbG93ZWRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGluc2VydFBvc2l0aW9uLCBpbnNlcnRDaGFyYWN0ZXIpIHx8IGluc2VydENoYXJhY3RlciA9PT0gbWFza0NoYXI7XG5cbiAgICBpZiAoIWlzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGluc2VydFBvc2l0aW9uIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICBpZiAobWFza0NoYXIgfHwgaXNJbnB1dEZpbGxlZCB8fCBpbnNlcnRQb3NpdGlvbiA8IHByZWZpeC5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpbnNlcnRQb3NpdGlvbikgKyBpbnNlcnRDaGFyYWN0ZXIgKyB2YWx1ZS5zbGljZShpbnNlcnRQb3NpdGlvbiArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpbnNlcnRQb3NpdGlvbikgKyBpbnNlcnRDaGFyYWN0ZXIgKyB2YWx1ZS5zbGljZShpbnNlcnRQb3NpdGlvbik7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0VmFsdWUobWFza09wdGlvbnMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFtYXNrQ2hhcikge1xuICAgICAgdmFsdWUgKz0gaW5zZXJ0Q2hhcmFjdGVyO1xuICAgIH1cblxuICAgIGluc2VydFBvc2l0aW9uKys7IC8vIHN0b3AgaXRlcmF0aW9uIGlmIG1heGltdW0gdmFsdWUgbGVuZ3RoIHJlYWNoZWRcblxuICAgIHJldHVybiBpbnNlcnRQb3NpdGlvbiA8IG1hc2subGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0SW5zZXJ0U3RyaW5nTGVuZ3RoKG1hc2tPcHRpb25zLCB2YWx1ZSwgaW5zZXJ0U3RyLCBpbnNlcnRQb3NpdGlvbikge1xuICB2YXIgbWFzayA9IG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICBtYXNrQ2hhciA9IG1hc2tPcHRpb25zLm1hc2tDaGFyO1xuICB2YXIgYXJyYXlJbnNlcnRTdHIgPSBpbnNlcnRTdHIuc3BsaXQoJycpO1xuICB2YXIgaW5pdGlhbEluc2VydFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb247XG5cbiAgdmFyIGlzVXNhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiBpc1VzYWJsZVBvc2l0aW9uKHBvcywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuICFpc1Blcm1hbmVudENoYXJhY3RlcihtYXNrT3B0aW9ucywgcG9zKSB8fCBjaGFyYWN0ZXIgPT09IG1hc2tbcG9zXTtcbiAgfTtcblxuICBhcnJheUluc2VydFN0ci5ldmVyeShmdW5jdGlvbiAoaW5zZXJ0Q2hhcmFjdGVyKSB7XG4gICAgd2hpbGUgKCFpc1VzYWJsZVBvc2l0aW9uKGluc2VydFBvc2l0aW9uLCBpbnNlcnRDaGFyYWN0ZXIpKSB7XG4gICAgICBpbnNlcnRQb3NpdGlvbisrOyAvLyBzdG9wIGl0ZXJhdGlvbiBpZiBtYXhpbXVtIHZhbHVlIGxlbmd0aCByZWFjaGVkXG5cbiAgICAgIGlmIChpbnNlcnRQb3NpdGlvbiA+PSBtYXNrLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzQWxsb3dlZENoYXJhY3RlcihtYXNrT3B0aW9ucywgaW5zZXJ0UG9zaXRpb24sIGluc2VydENoYXJhY3RlcikgfHwgaW5zZXJ0Q2hhcmFjdGVyID09PSBtYXNrQ2hhcjtcblxuICAgIGlmIChpc0FsbG93ZWQpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uKys7XG4gICAgfSAvLyBzdG9wIGl0ZXJhdGlvbiBpZiBtYXhpbXVtIHZhbHVlIGxlbmd0aCByZWFjaGVkXG5cblxuICAgIHJldHVybiBpbnNlcnRQb3NpdGlvbiA8IG1hc2subGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIGluc2VydFBvc2l0aW9uIC0gaW5pdGlhbEluc2VydFBvc2l0aW9uO1xufVxuZnVuY3Rpb24gZ2V0TGVmdEVkaXRhYmxlUG9zaXRpb24obWFza09wdGlvbnMsIHBvcykge1xuICBmb3IgKHZhciBpID0gcG9zOyBpID49IDA7IC0taSkge1xuICAgIGlmICghaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbihtYXNrT3B0aW9ucywgcG9zKSB7XG4gIHZhciBtYXNrID0gbWFza09wdGlvbnMubWFzaztcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgbWFzay5sZW5ndGg7ICsraSkge1xuICAgIGlmICghaXNQZXJtYW5lbnRDaGFyYWN0ZXIobWFza09wdGlvbnMsIGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiAhdmFsdWUgJiYgdmFsdWUgIT09IDAgPyAnJyA6IHZhbHVlICsgJyc7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGFuZ2UobWFza09wdGlvbnMsIHZhbHVlLCBzZWxlY3Rpb24sIHByZXZpb3VzVmFsdWUsIHByZXZpb3VzU2VsZWN0aW9uKSB7XG4gIHZhciBtYXNrID0gbWFza09wdGlvbnMubWFzayxcbiAgICAgIHByZWZpeCA9IG1hc2tPcHRpb25zLnByZWZpeCxcbiAgICAgIGxhc3RFZGl0YWJsZVBvc2l0aW9uID0gbWFza09wdGlvbnMubGFzdEVkaXRhYmxlUG9zaXRpb247XG4gIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuICB2YXIgZW50ZXJlZFN0cmluZyA9ICcnO1xuICB2YXIgZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCA9IDA7XG4gIHZhciByZW1vdmVkTGVuZ3RoID0gMDtcbiAgdmFyIGN1cnNvclBvc2l0aW9uID0gTWF0aC5taW4ocHJldmlvdXNTZWxlY3Rpb24uc3RhcnQsIHNlbGVjdGlvbi5zdGFydCk7XG5cbiAgaWYgKHNlbGVjdGlvbi5lbmQgPiBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCkge1xuICAgIGVudGVyZWRTdHJpbmcgPSBuZXdWYWx1ZS5zbGljZShwcmV2aW91c1NlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLmVuZCk7XG4gICAgZm9ybWF0dGVkRW50ZXJlZFN0cmluZ0xlbmd0aCA9IGdldEluc2VydFN0cmluZ0xlbmd0aChtYXNrT3B0aW9ucywgcHJldmlvdXNWYWx1ZSwgZW50ZXJlZFN0cmluZywgY3Vyc29yUG9zaXRpb24pO1xuXG4gICAgaWYgKCFmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoKSB7XG4gICAgICByZW1vdmVkTGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlZExlbmd0aCA9IHByZXZpb3VzU2VsZWN0aW9uLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV3VmFsdWUubGVuZ3RoIDwgcHJldmlvdXNWYWx1ZS5sZW5ndGgpIHtcbiAgICByZW1vdmVkTGVuZ3RoID0gcHJldmlvdXNWYWx1ZS5sZW5ndGggLSBuZXdWYWx1ZS5sZW5ndGg7XG4gIH1cblxuICBuZXdWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG5cbiAgaWYgKHJlbW92ZWRMZW5ndGgpIHtcbiAgICBpZiAocmVtb3ZlZExlbmd0aCA9PT0gMSAmJiAhcHJldmlvdXNTZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICB2YXIgZGVsZXRlRnJvbVJpZ2h0ID0gcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgPT09IHNlbGVjdGlvbi5zdGFydDtcbiAgICAgIGN1cnNvclBvc2l0aW9uID0gZGVsZXRlRnJvbVJpZ2h0ID8gZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKG1hc2tPcHRpb25zLCBzZWxlY3Rpb24uc3RhcnQpIDogZ2V0TGVmdEVkaXRhYmxlUG9zaXRpb24obWFza09wdGlvbnMsIHNlbGVjdGlvbi5zdGFydCk7XG4gICAgfVxuXG4gICAgbmV3VmFsdWUgPSBjbGVhclJhbmdlKG1hc2tPcHRpb25zLCBuZXdWYWx1ZSwgY3Vyc29yUG9zaXRpb24sIHJlbW92ZWRMZW5ndGgpO1xuICB9XG5cbiAgbmV3VmFsdWUgPSBpbnNlcnRTdHJpbmcobWFza09wdGlvbnMsIG5ld1ZhbHVlLCBlbnRlcmVkU3RyaW5nLCBjdXJzb3JQb3NpdGlvbik7XG4gIGN1cnNvclBvc2l0aW9uID0gY3Vyc29yUG9zaXRpb24gKyBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoO1xuXG4gIGlmIChjdXJzb3JQb3NpdGlvbiA+PSBtYXNrLmxlbmd0aCkge1xuICAgIGN1cnNvclBvc2l0aW9uID0gbWFzay5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoY3Vyc29yUG9zaXRpb24gPCBwcmVmaXgubGVuZ3RoICYmICFmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoKSB7XG4gICAgY3Vyc29yUG9zaXRpb24gPSBwcmVmaXgubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGN1cnNvclBvc2l0aW9uID49IHByZWZpeC5sZW5ndGggJiYgY3Vyc29yUG9zaXRpb24gPCBsYXN0RWRpdGFibGVQb3NpdGlvbiAmJiBmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoKSB7XG4gICAgY3Vyc29yUG9zaXRpb24gPSBnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24obWFza09wdGlvbnMsIGN1cnNvclBvc2l0aW9uKTtcbiAgfVxuXG4gIG5ld1ZhbHVlID0gZm9ybWF0VmFsdWUobWFza09wdGlvbnMsIG5ld1ZhbHVlKTtcblxuICBpZiAoIWVudGVyZWRTdHJpbmcpIHtcbiAgICBlbnRlcmVkU3RyaW5nID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgIGVudGVyZWRTdHJpbmc6IGVudGVyZWRTdHJpbmcsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBzdGFydDogY3Vyc29yUG9zaXRpb24sXG4gICAgICBlbmQ6IGN1cnNvclBvc2l0aW9uXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1dpbmRvd3NQaG9uZUJyb3dzZXIoKSB7XG4gIHZhciB3aW5kb3dzID0gbmV3IFJlZ0V4cCgnd2luZG93cycsICdpJyk7XG4gIHZhciBwaG9uZSA9IG5ldyBSZWdFeHAoJ3Bob25lJywgJ2knKTtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHdpbmRvd3MudGVzdCh1YSkgJiYgcGhvbmUudGVzdCh1YSk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkge1xuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGdldENhbmNlbEFuaW1hdGlvbkZyYW1lKCkge1xuICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZTtcbn1cblxuZnVuY3Rpb24gZGVmZXIoZm4pIHtcbiAgdmFyIGhhc0NhbmNlbEFuaW1hdGlvbkZyYW1lID0gISFnZXRDYW5jZWxBbmltYXRpb25GcmFtZSgpO1xuICB2YXIgZGVmZXJGbjtcblxuICBpZiAoaGFzQ2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICBkZWZlckZuID0gZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG4gIH0gZWxzZSB7XG4gICAgZGVmZXJGbiA9IGZ1bmN0aW9uIGRlZmVyRm4oKSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMTAwMCAvIDYwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRlZmVyRm4oZm4pO1xufVxuZnVuY3Rpb24gY2FuY2VsRGVmZXIoZGVmZXJJZCkge1xuICB2YXIgY2FuY2VsRm4gPSBnZXRDYW5jZWxBbmltYXRpb25GcmFtZSgpIHx8IGNsZWFyVGltZW91dDtcbiAgY2FuY2VsRm4oZGVmZXJJZCk7XG59XG5cbnZhciBJbnB1dEVsZW1lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5wdXRFbGVtZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBJbnB1dEVsZW1lbnQocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgX3RoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIF90aGlzLnByZXZpb3VzU2VsZWN0aW9uID0gbnVsbDtcbiAgICBfdGhpcy5zZWxlY3Rpb25EZWZlcklkID0gbnVsbDtcbiAgICBfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcERlZmVySWQgPSBudWxsO1xuXG4gICAgX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5wcmV2aW91c1NlbGVjdGlvbiA9IF90aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3BEZWZlcklkID0gZGVmZXIoX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3ApO1xuICAgIH07XG5cbiAgICBfdGhpcy5ydW5TYXZlU2VsZWN0aW9uTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcERlZmVySWQgPT09IG51bGwpIHtcbiAgICAgICAgX3RoaXMuc2F2ZVNlbGVjdGlvbkxvb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuc3RvcFNhdmVTZWxlY3Rpb25Mb29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnNhdmVTZWxlY3Rpb25Mb29wRGVmZXJJZCAhPT0gbnVsbCkge1xuICAgICAgICBjYW5jZWxEZWZlcihfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcERlZmVySWQpO1xuICAgICAgICBfdGhpcy5zYXZlU2VsZWN0aW9uTG9vcERlZmVySWQgPSBudWxsO1xuICAgICAgICBfdGhpcy5wcmV2aW91c1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldElucHV0RE9NTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMubW91bnRlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gcmVhY3REb20uZmluZERPTU5vZGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgICAgdmFyIGlzRE9NTm9kZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2Ygd2luZG93LkVsZW1lbnQ7IC8vIHdvcmthcm91bmQgZm9yIHJlYWN0LXRlc3QtcmVuZGVyZXJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzE0N1xuXG4gICAgICBpZiAoaW5wdXQgJiYgIWlzRE9NTm9kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0Lm5vZGVOYW1lICE9PSAnSU5QVVQnKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWN0LWlucHV0LW1hc2s6IGlucHV0Q29tcG9uZW50IGRvZXNuXFwndCBjb250YWluIGlucHV0IG5vZGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRJbnB1dFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlucHV0ID0gX3RoaXMuZ2V0SW5wdXRET01Ob2RlKCk7XG5cbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnB1dC52YWx1ZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGlucHV0ID0gX3RoaXMuZ2V0SW5wdXRET01Ob2RlKCk7XG5cbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0Q3Vyc29yVG9FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmlsbGVkTGVuZ3RoID0gZ2V0RmlsbGVkTGVuZ3RoKF90aGlzLm1hc2tPcHRpb25zLCBfdGhpcy52YWx1ZSk7XG4gICAgICB2YXIgcG9zID0gZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKF90aGlzLm1hc2tPcHRpb25zLCBmaWxsZWRMZW5ndGgpO1xuXG4gICAgICBpZiAocG9zICE9PSBudWxsKSB7XG4gICAgICAgIF90aGlzLnNldEN1cnNvclBvc2l0aW9uKHBvcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gX3RoaXMuZ2V0SW5wdXRET01Ob2RlKCk7XG5cbiAgICAgIHZhciBpc0ZvY3VzZWQgPSBfdGhpcy5pc0ZvY3VzZWQoKTsgLy8gZG9uJ3QgY2hhbmdlIHNlbGVjdGlvbiBvbiB1bmZvY3VzZWQgaW5wdXRcbiAgICAgIC8vIGJlY2F1c2UgU2FmYXJpIHNldHMgZm9jdXMgb24gc2VsZWN0aW9uIGNoYW5nZSAoIzE1NClcblxuXG4gICAgICBpZiAoIWlucHV0IHx8ICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICAgIGRlZmVycmVkID0gX29wdGlvbnMuZGVmZXJyZWQ7XG5cbiAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgc2V0SW5wdXRTZWxlY3Rpb24oaW5wdXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuc2VsZWN0aW9uRGVmZXJJZCAhPT0gbnVsbCkge1xuICAgICAgICBjYW5jZWxEZWZlcihfdGhpcy5zZWxlY3Rpb25EZWZlcklkKTtcbiAgICAgIH0gLy8gZGVmZXJyZWQgc2VsZWN0aW9uIHVwZGF0ZSBpcyByZXF1aXJlZCBmb3IgcHJlLUxvbGxpcG9wIEFuZHJvaWQgYnJvd3NlcixcbiAgICAgIC8vIGJ1dCBmb3IgY29uc2lzdGVudCBiZWhhdmlvciB3ZSBkbyBpdCBmb3IgYWxsIGJyb3dzZXJzXG5cblxuICAgICAgX3RoaXMuc2VsZWN0aW9uRGVmZXJJZCA9IGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc2VsZWN0aW9uRGVmZXJJZCA9IG51bGw7XG4gICAgICAgIHNldElucHV0U2VsZWN0aW9uKGlucHV0LCBzdGFydCwgZW5kKTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMucHJldmlvdXNTZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIGxlbmd0aDogTWF0aC5hYnMoZW5kIC0gc3RhcnQpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5wdXQgPSBfdGhpcy5nZXRJbnB1dERPTU5vZGUoKTtcblxuICAgICAgcmV0dXJuIGdldElucHV0U2VsZWN0aW9uKGlucHV0KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0Q3Vyc29yUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0U2VsZWN0aW9uKCkuc3RhcnQ7XG4gICAgfTtcblxuICAgIF90aGlzLnNldEN1cnNvclBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgX3RoaXMuc2V0U2VsZWN0aW9uKHBvcywgcG9zKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaXNGb2N1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmZvY3VzZWQ7XG4gICAgfTtcblxuICAgIF90aGlzLmdldEJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJG1hc2tPcHRpb25zID0gX3RoaXMubWFza09wdGlvbnMsXG4gICAgICAgICAgbWFzayA9IF90aGlzJG1hc2tPcHRpb25zLm1hc2ssXG4gICAgICAgICAgbWFza0NoYXIgPSBfdGhpcyRtYXNrT3B0aW9ucy5tYXNrQ2hhcixcbiAgICAgICAgICBwZXJtYW5lbnRzID0gX3RoaXMkbWFza09wdGlvbnMucGVybWFuZW50cyxcbiAgICAgICAgICBmb3JtYXRDaGFycyA9IF90aGlzJG1hc2tPcHRpb25zLmZvcm1hdENoYXJzO1xuICAgICAgdmFyIGFsd2F5c1Nob3dNYXNrID0gX3RoaXMucHJvcHMuYWx3YXlzU2hvd01hc2s7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXNrOiBtYXNrLFxuICAgICAgICBtYXNrQ2hhcjogbWFza0NoYXIsXG4gICAgICAgIHBlcm1hbmVudHM6IHBlcm1hbmVudHMsXG4gICAgICAgIGFsd2F5c1Nob3dNYXNrOiAhIWFsd2F5c1Nob3dNYXNrLFxuICAgICAgICBmb3JtYXRDaGFyczogZm9ybWF0Q2hhcnNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIF90aGlzLmlzSW5wdXRBdXRvZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBzZWxlY3Rpb24sIHByZXZpb3VzVmFsdWUsIHByZXZpb3VzU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5wdXQgPSBfdGhpcy5nZXRJbnB1dERPTU5vZGUoKTsgLy8gb25seSBjaGVjayBmb3IgcG9zaXRpdmUgbWF0Y2ggYmVjYXVzZSBpdCB3aWxsIGJlIGZhbHNlIG5lZ2F0aXZlXG4gICAgICAvLyBpbiBjYXNlIG9mIGF1dG9maWxsIHNpbXVsYXRpb24gaW4gdGVzdHNcbiAgICAgIC8vXG4gICAgICAvLyBpbnB1dC5tYXRjaGVzIHRocm93cyBhbiBleGNlcHRpb24gaWYgc2VsZWN0b3IgaXNuJ3Qgc3VwcG9ydGVkXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoZXMoJzotd2Via2l0LWF1dG9maWxsJykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge30gLy8gaWYgaW5wdXQgaXNuJ3QgZm9jdXNlZCB0aGVuIGNoYW5nZSBldmVudCBtdXN0IGhhdmUgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIC8vIGVpdGhlciBieSBhdXRvZmlsbCBvciBldmVudCBzaW11bGF0aW9uIGluIHRlc3RzXG5cblxuICAgICAgaWYgKCFfdGhpcy5mb2N1c2VkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBpZiBjdXJzb3IgaGFzIG1vdmVkIHRvIHRoZSBlbmQgd2hpbGUgcHJldmlvdXNTZWxlY3Rpb24gZm9yYmlkcyBpdFxuICAgICAgLy8gdGhlbiBpdCBtdXN0IGJlIGF1dG9maWxsXG5cblxuICAgICAgcmV0dXJuIHByZXZpb3VzU2VsZWN0aW9uLmVuZCA8IHByZXZpb3VzVmFsdWUubGVuZ3RoICYmIHNlbGVjdGlvbi5lbmQgPT09IHZhbHVlLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSxcbiAgICAgICAgICBiZWZvcmVQYXN0ZVN0YXRlID0gX2Fzc2VydFRoaXNJbml0aWFsaXplLmJlZm9yZVBhc3RlU3RhdGU7XG5cbiAgICAgIHZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemUyID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksXG4gICAgICAgICAgcHJldmlvdXNTZWxlY3Rpb24gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemUyLnByZXZpb3VzU2VsZWN0aW9uO1xuXG4gICAgICB2YXIgYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UgPSBfdGhpcy5wcm9wcy5iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZTtcblxuICAgICAgdmFyIHZhbHVlID0gX3RoaXMuZ2V0SW5wdXRWYWx1ZSgpO1xuXG4gICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IF90aGlzLnZhbHVlO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uID0gX3RoaXMuZ2V0U2VsZWN0aW9uKCk7IC8vIGF1dG9maWxsIHJlcGxhY2VzIGVudGlyZSB2YWx1ZSwgaWdub3JlIG9sZCBvbmVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5uaWFzc2luL3JlYWN0LWlucHV0LW1hc2svaXNzdWVzLzExM1xuXG5cbiAgICAgIGlmIChfdGhpcy5pc0lucHV0QXV0b2ZpbGxlZCh2YWx1ZSwgc2VsZWN0aW9uLCBwcmV2aW91c1ZhbHVlLCBwcmV2aW91c1NlbGVjdGlvbikpIHtcbiAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGZvcm1hdFZhbHVlKF90aGlzLm1hc2tPcHRpb25zLCAnJyk7XG4gICAgICAgIHByZXZpb3VzU2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gc2V0IHZhbHVlIGFuZCBzZWxlY3Rpb24gYXMgaWYgd2UgaGF2ZW4ndFxuICAgICAgLy8gY2xlYXJlZCBpbnB1dCBpbiBvblBhc3RlIGhhbmRsZXJcblxuXG4gICAgICBpZiAoYmVmb3JlUGFzdGVTdGF0ZSkge1xuICAgICAgICBwcmV2aW91c1NlbGVjdGlvbiA9IGJlZm9yZVBhc3RlU3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBwcmV2aW91c1ZhbHVlID0gYmVmb3JlUGFzdGVTdGF0ZS52YWx1ZTtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiBwcmV2aW91c1NlbGVjdGlvbi5zdGFydCArIHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICBlbmQ6IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0ICsgdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9O1xuICAgICAgICB2YWx1ZSA9IHByZXZpb3VzVmFsdWUuc2xpY2UoMCwgcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQpICsgdmFsdWUgKyBwcmV2aW91c1ZhbHVlLnNsaWNlKHByZXZpb3VzU2VsZWN0aW9uLmVuZCk7XG4gICAgICAgIF90aGlzLmJlZm9yZVBhc3RlU3RhdGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlZFN0YXRlID0gcHJvY2Vzc0NoYW5nZShfdGhpcy5tYXNrT3B0aW9ucywgdmFsdWUsIHNlbGVjdGlvbiwgcHJldmlvdXNWYWx1ZSwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgdmFyIGVudGVyZWRTdHJpbmcgPSBjaGFuZ2VkU3RhdGUuZW50ZXJlZFN0cmluZztcbiAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBjaGFuZ2VkU3RhdGUuc2VsZWN0aW9uO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY2hhbmdlZFN0YXRlLnZhbHVlO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSkpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSh7XG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvbjogbmV3U2VsZWN0aW9uXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB2YWx1ZTogcHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICBzZWxlY3Rpb246IHByZXZpb3VzU2VsZWN0aW9uXG4gICAgICAgIH0sIGVudGVyZWRTdHJpbmcsIF90aGlzLmdldEJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlQ29uZmlnKCkpO1xuICAgICAgICBuZXdWYWx1ZSA9IG1vZGlmaWVkVmFsdWUudmFsdWU7XG4gICAgICAgIG5ld1NlbGVjdGlvbiA9IG1vZGlmaWVkVmFsdWUuc2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zZXRJbnB1dFZhbHVlKG5ld1ZhbHVlKTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25DaGFuZ2UpKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmlzV2luZG93c1Bob25lQnJvd3Nlcikge1xuICAgICAgICBfdGhpcy5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uLnN0YXJ0LCBuZXdTZWxlY3Rpb24uZW5kLCB7XG4gICAgICAgICAgZGVmZXJyZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uLnN0YXJ0LCBuZXdTZWxlY3Rpb24uZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlID0gX3RoaXMucHJvcHMuYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2U7XG4gICAgICB2YXIgX3RoaXMkbWFza09wdGlvbnMyID0gX3RoaXMubWFza09wdGlvbnMsXG4gICAgICAgICAgbWFzayA9IF90aGlzJG1hc2tPcHRpb25zMi5tYXNrLFxuICAgICAgICAgIHByZWZpeCA9IF90aGlzJG1hc2tPcHRpb25zMi5wcmVmaXg7XG4gICAgICBfdGhpcy5mb2N1c2VkID0gdHJ1ZTsgLy8gaWYgYXV0b0ZvY3VzIGlzIHNldCwgb25Gb2N1cyB0cmlnZ2VycyBiZWZvcmUgY29tcG9uZW50RGlkTW91bnRcblxuICAgICAgX3RoaXMubW91bnRlZCA9IHRydWU7XG5cbiAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgIGlmICghX3RoaXMudmFsdWUpIHtcbiAgICAgICAgICB2YXIgZW1wdHlWYWx1ZSA9IGZvcm1hdFZhbHVlKF90aGlzLm1hc2tPcHRpb25zLCBwcmVmaXgpO1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGZvcm1hdFZhbHVlKF90aGlzLm1hc2tPcHRpb25zLCBlbXB0eVZhbHVlKTtcbiAgICAgICAgICB2YXIgZmlsbGVkTGVuZ3RoID0gZ2V0RmlsbGVkTGVuZ3RoKF90aGlzLm1hc2tPcHRpb25zLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gZ2V0UmlnaHRFZGl0YWJsZVBvc2l0aW9uKF90aGlzLm1hc2tPcHRpb25zLCBmaWxsZWRMZW5ndGgpO1xuICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICBzdGFydDogY3Vyc29yUG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGN1cnNvclBvc2l0aW9uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKSkge1xuICAgICAgICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSh7XG4gICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IF90aGlzLnZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgICAgIH0sIG51bGwsIF90aGlzLmdldEJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlQ29uZmlnKCkpO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBtb2RpZmllZFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gbW9kaWZpZWRWYWx1ZS5zZWxlY3Rpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzSW5wdXRWYWx1ZUNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gX3RoaXMuZ2V0SW5wdXRWYWx1ZSgpO1xuXG4gICAgICAgICAgaWYgKGlzSW5wdXRWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnNldElucHV0VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0lucHV0VmFsdWVDaGFuZ2VkICYmIGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25DaGFuZ2UpKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbi5zdGFydCwgbmV3U2VsZWN0aW9uLmVuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2V0RmlsbGVkTGVuZ3RoKF90aGlzLm1hc2tPcHRpb25zLCBfdGhpcy52YWx1ZSkgPCBfdGhpcy5tYXNrT3B0aW9ucy5tYXNrLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzLnNldEN1cnNvclRvRW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5ydW5TYXZlU2VsZWN0aW9uTG9vcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vbkZvY3VzKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkZvY3VzKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25CbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UgPSBfdGhpcy5wcm9wcy5iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZTtcbiAgICAgIHZhciBtYXNrID0gX3RoaXMubWFza09wdGlvbnMubWFzaztcblxuICAgICAgX3RoaXMuc3RvcFNhdmVTZWxlY3Rpb25Mb29wKCk7XG5cbiAgICAgIF90aGlzLmZvY3VzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKG1hc2sgJiYgIV90aGlzLnByb3BzLmFsd2F5c1Nob3dNYXNrICYmIGlzRW1wdHkoX3RoaXMubWFza09wdGlvbnMsIF90aGlzLnZhbHVlKSkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSAnJztcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSkpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogbnVsbFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiBfdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogX3RoaXMucHJldmlvdXNTZWxlY3Rpb25cbiAgICAgICAgICB9LCBudWxsLCBfdGhpcy5nZXRCZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZUNvbmZpZygpKTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG1vZGlmaWVkVmFsdWUudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNJbnB1dFZhbHVlQ2hhbmdlZCA9IG5ld1ZhbHVlICE9PSBfdGhpcy5nZXRJbnB1dFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGlzSW5wdXRWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgICBfdGhpcy5zZXRJbnB1dFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0lucHV0VmFsdWVDaGFuZ2VkICYmIGlzRnVuY3Rpb24oX3RoaXMucHJvcHMub25DaGFuZ2UpKSB7XG4gICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLnByb3BzLm9uQmx1cikpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25CbHVyKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIHRpbnkgdW5pbnRlbnRpb25hbCBtb3VzZSBtb3ZlbWVudHMgY2FuIGJyZWFrIGN1cnNvclxuICAgICAgLy8gcG9zaXRpb24gb24gZm9jdXMsIHNvIHdlIGhhdmUgdG8gcmVzdG9yZSBpdCBpbiB0aGF0IGNhc2VcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fubmlhc3Npbi9yZWFjdC1pbnB1dC1tYXNrL2lzc3Vlcy8xMDhcbiAgICAgIGlmICghX3RoaXMuZm9jdXNlZCAmJiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIF90aGlzLm1vdXNlRG93blggPSBldmVudC5jbGllbnRYO1xuICAgICAgICBfdGhpcy5tb3VzZURvd25ZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgX3RoaXMubW91c2VEb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHZhciBtb3VzZVVwSGFuZGxlciA9IGZ1bmN0aW9uIG1vdXNlVXBIYW5kbGVyKG1vdXNlVXBFdmVudCkge1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG5cbiAgICAgICAgICBpZiAoIV90aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVsdGFYID0gTWF0aC5hYnMobW91c2VVcEV2ZW50LmNsaWVudFggLSBfdGhpcy5tb3VzZURvd25YKTtcbiAgICAgICAgICB2YXIgZGVsdGFZID0gTWF0aC5hYnMobW91c2VVcEV2ZW50LmNsaWVudFkgLSBfdGhpcy5tb3VzZURvd25ZKTtcbiAgICAgICAgICB2YXIgYXhpc0RlbHRhID0gTWF0aC5tYXgoZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgICAgICAgdmFyIHRpbWVEZWx0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gX3RoaXMubW91c2VEb3duVGltZTtcblxuICAgICAgICAgIGlmIChheGlzRGVsdGEgPD0gMTAgJiYgdGltZURlbHRhIDw9IDIwMCB8fCBheGlzRGVsdGEgPD0gNSAmJiB0aW1lRGVsdGEgPD0gMzAwKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRDdXJzb3JUb0VuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vbk1vdXNlRG93bikpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vblBhc3RlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5wcm9wcy5vblBhc3RlKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vblBhc3RlKGV2ZW50KTtcbiAgICAgIH0gLy8gZXZlbnQuY2xpcGJvYXJkRGF0YSBtaWdodCBub3Qgd29yayBpbiBBbmRyb2lkIGJyb3dzZXJcbiAgICAgIC8vIGNsZWFuaW5nIGlucHV0IHRvIGdldCByYXcgdGV4dCBpbnNpZGUgb25DaGFuZ2UgaGFuZGxlclxuXG5cbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBfdGhpcy5iZWZvcmVQYXN0ZVN0YXRlID0ge1xuICAgICAgICAgIHZhbHVlOiBfdGhpcy5nZXRJbnB1dFZhbHVlKCksXG4gICAgICAgICAgc2VsZWN0aW9uOiBfdGhpcy5nZXRTZWxlY3Rpb24oKVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnNldElucHV0VmFsdWUoJycpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBpc0Z1bmN0aW9uKF90aGlzLnByb3BzLmlucHV0UmVmKSkge1xuICAgICAgICBfdGhpcy5wcm9wcy5pbnB1dFJlZihyZWYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX21hc2sgPSBwcm9wcy5tYXNrLFxuICAgICAgICBfbWFza0NoYXIgPSBwcm9wcy5tYXNrQ2hhcixcbiAgICAgICAgX2Zvcm1hdENoYXJzID0gcHJvcHMuZm9ybWF0Q2hhcnMsXG4gICAgICAgIF9hbHdheXNTaG93TWFzayA9IHByb3BzLmFsd2F5c1Nob3dNYXNrLFxuICAgICAgICBfYmVmb3JlTWFza2VkVmFsdWVDaGFuZ2UgPSBwcm9wcy5iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBfdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgICBfdGhpcy5tYXNrT3B0aW9ucyA9IHBhcnNlTWFzayhfbWFzaywgX21hc2tDaGFyLCBfZm9ybWF0Q2hhcnMpO1xuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAoX3ZhbHVlID09IG51bGwpIHtcbiAgICAgIF92YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX25ld1ZhbHVlID0gZ2V0U3RyaW5nVmFsdWUoX3ZhbHVlKTtcblxuICAgIGlmIChfdGhpcy5tYXNrT3B0aW9ucy5tYXNrICYmIChfYWx3YXlzU2hvd01hc2sgfHwgX25ld1ZhbHVlKSkge1xuICAgICAgX25ld1ZhbHVlID0gZm9ybWF0VmFsdWUoX3RoaXMubWFza09wdGlvbnMsIF9uZXdWYWx1ZSk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKF9iZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSkpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBvbGRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZFZhbHVlID0gZ2V0U3RyaW5nVmFsdWUob2xkVmFsdWUpO1xuXG4gICAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gX2JlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKHtcbiAgICAgICAgICB2YWx1ZTogX25ld1ZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvbjogbnVsbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgIHNlbGVjdGlvbjogbnVsbFxuICAgICAgICB9LCBudWxsLCBfdGhpcy5nZXRCZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZUNvbmZpZygpKTtcblxuICAgICAgICBfbmV3VmFsdWUgPSBtb2RpZmllZFZhbHVlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnZhbHVlID0gX25ld1ZhbHVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbnB1dEVsZW1lbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7IC8vIHdvcmthcm91bmQgZm9yIHJlYWN0LXRlc3QtcmVuZGVyZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fubmlhc3Npbi9yZWFjdC1pbnB1dC1tYXNrL2lzc3Vlcy8xNDdcblxuICAgIGlmICghdGhpcy5nZXRJbnB1dERPTU5vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNXaW5kb3dzUGhvbmVCcm93c2VyID0gaXNXaW5kb3dzUGhvbmVCcm93c2VyKCk7XG5cbiAgICBpZiAodGhpcy5tYXNrT3B0aW9ucy5tYXNrICYmIHRoaXMuZ2V0SW5wdXRWYWx1ZSgpICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICB0aGlzLnNldElucHV0VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdmFyIHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5wcmV2aW91c1NlbGVjdGlvbjtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSA9IF90aGlzJHByb3BzLmJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlLFxuICAgICAgICBhbHdheXNTaG93TWFzayA9IF90aGlzJHByb3BzLmFsd2F5c1Nob3dNYXNrLFxuICAgICAgICBtYXNrID0gX3RoaXMkcHJvcHMubWFzayxcbiAgICAgICAgbWFza0NoYXIgPSBfdGhpcyRwcm9wcy5tYXNrQ2hhcixcbiAgICAgICAgZm9ybWF0Q2hhcnMgPSBfdGhpcyRwcm9wcy5mb3JtYXRDaGFycztcbiAgICB2YXIgcHJldmlvdXNNYXNrT3B0aW9ucyA9IHRoaXMubWFza09wdGlvbnM7XG4gICAgdmFyIHNob3dFbXB0eSA9IGFsd2F5c1Nob3dNYXNrIHx8IHRoaXMuaXNGb2N1c2VkKCk7XG4gICAgdmFyIGhhc1ZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZSAhPSBudWxsO1xuICAgIHZhciBuZXdWYWx1ZSA9IGhhc1ZhbHVlID8gZ2V0U3RyaW5nVmFsdWUodGhpcy5wcm9wcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IHByZXZpb3VzU2VsZWN0aW9uID8gcHJldmlvdXNTZWxlY3Rpb24uc3RhcnQgOiBudWxsO1xuICAgIHRoaXMubWFza09wdGlvbnMgPSBwYXJzZU1hc2sobWFzaywgbWFza0NoYXIsIGZvcm1hdENoYXJzKTtcblxuICAgIGlmICghdGhpcy5tYXNrT3B0aW9ucy5tYXNrKSB7XG4gICAgICBpZiAocHJldmlvdXNNYXNrT3B0aW9ucy5tYXNrKSB7XG4gICAgICAgIHRoaXMuc3RvcFNhdmVTZWxlY3Rpb25Mb29wKCk7IC8vIHJlbmRlciBkZXBlbmRzIG9uIHRoaXMubWFza09wdGlvbnMgYW5kIHRoaXMudmFsdWUsXG4gICAgICAgIC8vIGNhbGwgZm9yY2VVcGRhdGUgdG8ga2VlcCBpdCBpbiBzeW5jXG5cbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghcHJldmlvdXNNYXNrT3B0aW9ucy5tYXNrICYmIHRoaXMuaXNGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMucnVuU2F2ZVNlbGVjdGlvbkxvb3AoKTtcbiAgICB9XG5cbiAgICB2YXIgaXNNYXNrQ2hhbmdlZCA9IHRoaXMubWFza09wdGlvbnMubWFzayAmJiB0aGlzLm1hc2tPcHRpb25zLm1hc2sgIT09IHByZXZpb3VzTWFza09wdGlvbnMubWFzaztcblxuICAgIGlmICghcHJldmlvdXNNYXNrT3B0aW9ucy5tYXNrICYmICFoYXNWYWx1ZSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXNrQ2hhbmdlZCB8fCB0aGlzLm1hc2tPcHRpb25zLm1hc2sgJiYgKG5ld1ZhbHVlIHx8IHNob3dFbXB0eSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gZm9ybWF0VmFsdWUodGhpcy5tYXNrT3B0aW9ucywgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChpc01hc2tDaGFuZ2VkKSB7XG4gICAgICB2YXIgZmlsbGVkTGVuZ3RoID0gZ2V0RmlsbGVkTGVuZ3RoKHRoaXMubWFza09wdGlvbnMsIG5ld1ZhbHVlKTtcblxuICAgICAgaWYgKGN1cnNvclBvc2l0aW9uID09PSBudWxsIHx8IGZpbGxlZExlbmd0aCA8IGN1cnNvclBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChpc0ZpbGxlZCh0aGlzLm1hc2tPcHRpb25zLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IGZpbGxlZExlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IGdldFJpZ2h0RWRpdGFibGVQb3NpdGlvbih0aGlzLm1hc2tPcHRpb25zLCBmaWxsZWRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFza09wdGlvbnMubWFzayAmJiBpc0VtcHR5KHRoaXMubWFza09wdGlvbnMsIG5ld1ZhbHVlKSAmJiAhc2hvd0VtcHR5ICYmICghaGFzVmFsdWUgfHwgIXRoaXMucHJvcHMudmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB7XG4gICAgICBzdGFydDogY3Vyc29yUG9zaXRpb24sXG4gICAgICBlbmQ6IGN1cnNvclBvc2l0aW9uXG4gICAgfTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlKSkge1xuICAgICAgdmFyIG1vZGlmaWVkVmFsdWUgPSBiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZSh7XG4gICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvbjogdGhpcy5wcmV2aW91c1NlbGVjdGlvblxuICAgICAgfSwgbnVsbCwgdGhpcy5nZXRCZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZUNvbmZpZygpKTtcbiAgICAgIG5ld1ZhbHVlID0gbW9kaWZpZWRWYWx1ZS52YWx1ZTtcbiAgICAgIG5ld1NlbGVjdGlvbiA9IG1vZGlmaWVkVmFsdWUuc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB2YXIgaXNWYWx1ZUNoYW5nZWQgPSB0aGlzLmdldElucHV0VmFsdWUoKSAhPT0gdGhpcy52YWx1ZTsgLy8gcmVuZGVyIGRlcGVuZHMgb24gdGhpcy5tYXNrT3B0aW9ucyBhbmQgdGhpcy52YWx1ZSxcbiAgICAvLyBjYWxsIGZvcmNlVXBkYXRlIHRvIGtlZXAgaXQgaW4gc3luY1xuXG4gICAgaWYgKGlzVmFsdWVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldElucHV0VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfSBlbHNlIGlmIChpc01hc2tDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGlzU2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgaWYgKG5ld1NlbGVjdGlvbi5zdGFydCAhPSBudWxsICYmIG5ld1NlbGVjdGlvbi5lbmQgIT0gbnVsbCkge1xuICAgICAgaXNTZWxlY3Rpb25DaGFuZ2VkID0gIXByZXZpb3VzU2VsZWN0aW9uIHx8IHByZXZpb3VzU2VsZWN0aW9uLnN0YXJ0ICE9PSBuZXdTZWxlY3Rpb24uc3RhcnQgfHwgcHJldmlvdXNTZWxlY3Rpb24uZW5kICE9PSBuZXdTZWxlY3Rpb24uZW5kO1xuICAgIH1cblxuICAgIGlmIChpc1NlbGVjdGlvbkNoYW5nZWQgfHwgaXNWYWx1ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbi5zdGFydCwgbmV3U2VsZWN0aW9uLmVuZCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uRGVmZXJJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsRGVmZXIodGhpcy5zZWxlY3Rpb25EZWZlcklkKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BTYXZlU2VsZWN0aW9uTG9vcCgpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIG1hc2sgPSBfdGhpcyRwcm9wczIubWFzayxcbiAgICAgICAgYWx3YXlzU2hvd01hc2sgPSBfdGhpcyRwcm9wczIuYWx3YXlzU2hvd01hc2ssXG4gICAgICAgIG1hc2tDaGFyID0gX3RoaXMkcHJvcHMyLm1hc2tDaGFyLFxuICAgICAgICBmb3JtYXRDaGFycyA9IF90aGlzJHByb3BzMi5mb3JtYXRDaGFycyxcbiAgICAgICAgaW5wdXRSZWYgPSBfdGhpcyRwcm9wczIuaW5wdXRSZWYsXG4gICAgICAgIGJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlID0gX3RoaXMkcHJvcHMyLmJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbixcbiAgICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBbXCJtYXNrXCIsIFwiYWx3YXlzU2hvd01hc2tcIiwgXCJtYXNrQ2hhclwiLCBcImZvcm1hdENoYXJzXCIsIFwiaW5wdXRSZWZcIiwgXCJiZWZvcmVNYXNrZWRWYWx1ZUNoYW5nZVwiLCBcImNoaWxkcmVuXCJdKTtcblxuICAgIHZhciBpbnB1dEVsZW1lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyggLy8gcGFyc2UgbWFzayB0byB0ZXN0IGFnYWluc3QgYWN0dWFsIG1hc2sgcHJvcCBhcyB0aGlzLm1hc2tPcHRpb25zXG4gICAgLy8gd2lsbCBiZSB1cGRhdGVkIGxhdGVyIGluIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICFyZXN0UHJvcHMubWF4TGVuZ3RoIHx8ICFwYXJzZU1hc2sobWFzaywgbWFza0NoYXIsIGZvcm1hdENoYXJzKS5tYXNrLCAncmVhY3QtaW5wdXQtbWFzazogbWF4TGVuZ3RoIHByb3BlcnR5IHNob3VsZG5cXCd0IGJlIHBhc3NlZCB0byB0aGUgbWFza2VkIGlucHV0LiBJdCBicmVha3MgbWFza2luZyBhbmQgdW5uZWNlc3NhcnkgYmVjYXVzZSBsZW5ndGggaXMgbGltaXRlZCBieSB0aGUgbWFzayBsZW5ndGguJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICFpc0Z1bmN0aW9uKGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ3JlYWN0LWlucHV0LW1hc2s6IGNoaWxkcmVuIG11c3QgYmUgYSBmdW5jdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBjb250cm9sbGVkUHJvcHMgPSBbJ29uQ2hhbmdlJywgJ29uUGFzdGUnLCAnb25Nb3VzZURvd24nLCAnb25Gb2N1cycsICdvbkJsdXInLCAndmFsdWUnLCAnZGlzYWJsZWQnLCAncmVhZE9ubHknXTtcblxuICAgICAgdmFyIGNoaWxkcmVuUHJvcHMgPSBfZXh0ZW5kcyh7fSwgcmVzdFByb3BzKTtcblxuICAgICAgY29udHJvbGxlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3BJZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlIGNoaWxkcmVuUHJvcHNbcHJvcElkXTtcbiAgICAgIH0pO1xuICAgICAgaW5wdXRFbGVtZW50ID0gY2hpbGRyZW4oY2hpbGRyZW5Qcm9wcyk7XG4gICAgICB2YXIgY29uZmxpY3RQcm9wcyA9IGNvbnRyb2xsZWRQcm9wcy5maWx0ZXIoZnVuY3Rpb24gKHByb3BJZCkge1xuICAgICAgICByZXR1cm4gaW5wdXRFbGVtZW50LnByb3BzW3Byb3BJZF0gIT0gbnVsbCAmJiBpbnB1dEVsZW1lbnQucHJvcHNbcHJvcElkXSAhPT0gcmVzdFByb3BzW3Byb3BJZF07XG4gICAgICB9KTtcbiAgICAgICEhY29uZmxpY3RQcm9wcy5sZW5ndGggPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwicmVhY3QtaW5wdXQtbWFzazogdGhlIGZvbGxvd2luZyBwcm9wcyBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSByZWFjdC1pbnB1dC1tYXNrJ3MgY29tcG9uZW50IGFuZCBzaG91bGQgbm90IGJlIGFsdGVyZWQgaW4gY2hpbGRyZW4ncyBmdW5jdGlvbjogXCIgKyBjb25mbGljdFByb3BzLmpvaW4oJywgJykpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIWlucHV0UmVmLCAncmVhY3QtaW5wdXQtbWFzazogaW5wdXRSZWYgaXMgaWdub3JlZCB3aGVuIGNoaWxkcmVuIGlzIHBhc3NlZCwgYXR0YWNoIHJlZiB0byB0aGUgY2hpbGRyZW4gaW5zdGVhZCcpIDogdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IHRoaXMuaGFuZGxlUmVmXG4gICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZFByb3BzID0ge1xuICAgICAgb25Gb2N1czogdGhpcy5vbkZvY3VzLFxuICAgICAgb25CbHVyOiB0aGlzLm9uQmx1clxuICAgIH07XG5cbiAgICBpZiAodGhpcy5tYXNrT3B0aW9ucy5tYXNrKSB7XG4gICAgICBpZiAoIXJlc3RQcm9wcy5kaXNhYmxlZCAmJiAhcmVzdFByb3BzLnJlYWRPbmx5KSB7XG4gICAgICAgIGNoYW5nZWRQcm9wcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2U7XG4gICAgICAgIGNoYW5nZWRQcm9wcy5vblBhc3RlID0gdGhpcy5vblBhc3RlO1xuICAgICAgICBjaGFuZ2VkUHJvcHMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdFByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY2hhbmdlZFByb3BzLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnB1dEVsZW1lbnQgPSBSZWFjdC5jbG9uZUVsZW1lbnQoaW5wdXRFbGVtZW50LCBjaGFuZ2VkUHJvcHMpO1xuICAgIHJldHVybiBpbnB1dEVsZW1lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIElucHV0RWxlbWVudDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dEVsZW1lbnQ7XG4iXSwibmFtZXMiOlsiX2ludGVyb3BEZWZhdWx0IiwiZXgiLCJSZWFjdCIsInJlcXVpcmUiLCJyZWFjdERvbSIsImludmFyaWFudCIsIndhcm5pbmciLCJfZGVmYXVsdHMyIiwib2JqIiwiZGVmYXVsdHMiLCJrZXlzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImkiLCJsZW5ndGgiLCJrZXkiLCJ2YWx1ZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsInVuZGVmaW5lZCIsImRlZmluZVByb3BlcnR5IiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwic2V0SW5wdXRTZWxlY3Rpb24iLCJpbnB1dCIsInN0YXJ0IiwiZW5kIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJyYW5nZSIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwibW92ZVN0YXJ0IiwibW92ZUVuZCIsInNlbGVjdCIsImdldElucHV0U2VsZWN0aW9uIiwiZG9jdW1lbnQiLCJzZWxlY3Rpb24iLCJjcmVhdGVSYW5nZSIsInBhcmVudEVsZW1lbnQiLCJkZWZhdWx0Rm9ybWF0Q2hhcnMiLCJkZWZhdWx0TWFza0NoYXIiLCJwYXJzZU1hc2siLCJtYXNrIiwibWFza0NoYXIiLCJmb3JtYXRDaGFycyIsInBhcnNlZE1hc2tTdHJpbmciLCJwcmVmaXgiLCJsYXN0RWRpdGFibGVQb3NpdGlvbiIsInBlcm1hbmVudHMiLCJpc1Blcm1hbmVudCIsInNwbGl0IiwiZm9yRWFjaCIsImNoYXJhY3RlciIsInB1c2giLCJpc1Blcm1hbmVudENoYXJhY3RlciIsIm1hc2tPcHRpb25zIiwicG9zIiwiaXNBbGxvd2VkQ2hhcmFjdGVyIiwicnVsZUNoYXIiLCJjaGFyUnVsZSIsIlJlZ0V4cCIsInRlc3QiLCJpc0VtcHR5IiwiZXZlcnkiLCJnZXRGaWxsZWRMZW5ndGgiLCJzbGljZSIsImZpbGxlZExlbmd0aCIsImlzRW50ZXJlZENoYXJhY3RlciIsImlzRmlsbGVkIiwiZm9ybWF0VmFsdWUiLCJpbnNlcnRTdHJpbmciLCJlbXB0eVZhbHVlIiwiY2xlYXJSYW5nZSIsImxlbiIsImFycmF5VmFsdWUiLCJNYXRoIiwibWF4Iiwic3BsaWNlIiwiam9pbiIsIm1hcCIsImluc2VydFN0ciIsImluc2VydFBvc2l0aW9uIiwiYXJyYXlJbnNlcnRTdHIiLCJpc0lucHV0RmlsbGVkIiwiaXNVc2FibGVQb3NpdGlvbiIsImlzVXNhYmxlQ2hhcmFjdGVyIiwiaW5zZXJ0Q2hhcmFjdGVyIiwiaXNBbGxvd2VkIiwiZ2V0SW5zZXJ0U3RyaW5nTGVuZ3RoIiwiaW5pdGlhbEluc2VydFBvc2l0aW9uIiwiZ2V0TGVmdEVkaXRhYmxlUG9zaXRpb24iLCJnZXRSaWdodEVkaXRhYmxlUG9zaXRpb24iLCJnZXRTdHJpbmdWYWx1ZSIsInByb2Nlc3NDaGFuZ2UiLCJwcmV2aW91c1ZhbHVlIiwicHJldmlvdXNTZWxlY3Rpb24iLCJuZXdWYWx1ZSIsImVudGVyZWRTdHJpbmciLCJmb3JtYXR0ZWRFbnRlcmVkU3RyaW5nTGVuZ3RoIiwicmVtb3ZlZExlbmd0aCIsImN1cnNvclBvc2l0aW9uIiwibWluIiwiZGVsZXRlRnJvbVJpZ2h0IiwiaXNXaW5kb3dzUGhvbmVCcm93c2VyIiwid2luZG93cyIsInBob25lIiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0Z1bmN0aW9uIiwiZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZ2V0Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIiwibW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkZWZlciIsImZuIiwiaGFzQ2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkZWZlckZuIiwic2V0VGltZW91dCIsImNhbmNlbERlZmVyIiwiZGVmZXJJZCIsImNhbmNlbEZuIiwiY2xlYXJUaW1lb3V0IiwiSW5wdXRFbGVtZW50IiwiX1JlYWN0JENvbXBvbmVudCIsInByb3BzIiwiX3RoaXMiLCJmb2N1c2VkIiwibW91bnRlZCIsInNlbGVjdGlvbkRlZmVySWQiLCJzYXZlU2VsZWN0aW9uTG9vcERlZmVySWQiLCJzYXZlU2VsZWN0aW9uTG9vcCIsImdldFNlbGVjdGlvbiIsInJ1blNhdmVTZWxlY3Rpb25Mb29wIiwic3RvcFNhdmVTZWxlY3Rpb25Mb29wIiwiZ2V0SW5wdXRET01Ob2RlIiwiZmluZERPTU5vZGUiLCJpc0RPTU5vZGUiLCJFbGVtZW50Iiwibm9kZU5hbWUiLCJxdWVyeVNlbGVjdG9yIiwiRXJyb3IiLCJnZXRJbnB1dFZhbHVlIiwic2V0SW5wdXRWYWx1ZSIsInNldEN1cnNvclRvRW5kIiwic2V0Q3Vyc29yUG9zaXRpb24iLCJzZXRTZWxlY3Rpb24iLCJvcHRpb25zIiwiaXNGb2N1c2VkIiwiX29wdGlvbnMiLCJkZWZlcnJlZCIsImFicyIsImdldEN1cnNvclBvc2l0aW9uIiwiZ2V0QmVmb3JlTWFza2VkVmFsdWVDaGFuZ2VDb25maWciLCJfdGhpcyRtYXNrT3B0aW9ucyIsImFsd2F5c1Nob3dNYXNrIiwiaXNJbnB1dEF1dG9maWxsZWQiLCJtYXRjaGVzIiwiZSIsIm9uQ2hhbmdlIiwiZXZlbnQiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemUiLCJiZWZvcmVQYXN0ZVN0YXRlIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplMiIsImJlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlIiwiY2hhbmdlZFN0YXRlIiwibmV3U2VsZWN0aW9uIiwibW9kaWZpZWRWYWx1ZSIsIm9uRm9jdXMiLCJfdGhpcyRtYXNrT3B0aW9uczIiLCJpc0lucHV0VmFsdWVDaGFuZ2VkIiwib25CbHVyIiwib25Nb3VzZURvd24iLCJhZGRFdmVudExpc3RlbmVyIiwibW91c2VEb3duWCIsImNsaWVudFgiLCJtb3VzZURvd25ZIiwiY2xpZW50WSIsIm1vdXNlRG93blRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsIm1vdXNlVXBIYW5kbGVyIiwibW91c2VVcEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlbHRhWCIsImRlbHRhWSIsImF4aXNEZWx0YSIsInRpbWVEZWx0YSIsIm9uUGFzdGUiLCJkZWZhdWx0UHJldmVudGVkIiwiaGFuZGxlUmVmIiwicmVmIiwiY2hpbGRyZW4iLCJpbnB1dFJlZiIsIl9tYXNrIiwiX21hc2tDaGFyIiwiX2Zvcm1hdENoYXJzIiwiX2Fsd2F5c1Nob3dNYXNrIiwiX2JlZm9yZU1hc2tlZFZhbHVlQ2hhbmdlIiwiZGVmYXVsdFZhbHVlIiwiX3ZhbHVlIiwiX25ld1ZhbHVlIiwib2xkVmFsdWUiLCJfcHJvdG8iLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsIl90aGlzJHByb3BzIiwicHJldmlvdXNNYXNrT3B0aW9ucyIsInNob3dFbXB0eSIsImhhc1ZhbHVlIiwiZm9yY2VVcGRhdGUiLCJpc01hc2tDaGFuZ2VkIiwiaXNWYWx1ZUNoYW5nZWQiLCJpc1NlbGVjdGlvbkNoYW5nZWQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsIl90aGlzJHByb3BzMiIsInJlc3RQcm9wcyIsImlucHV0RWxlbWVudCIsIm1heExlbmd0aCIsInByb2Nlc3MiLCJjb250cm9sbGVkUHJvcHMiLCJjaGlsZHJlblByb3BzIiwicHJvcElkIiwiY29uZmxpY3RQcm9wcyIsImZpbHRlciIsImNyZWF0ZUVsZW1lbnQiLCJjaGFuZ2VkUHJvcHMiLCJkaXNhYmxlZCIsInJlYWRPbmx5IiwiY2xvbmVFbGVtZW50IiwiQ29tcG9uZW50IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-input-mask/lib/react-input-mask.development.js\n");

/***/ })

};
;